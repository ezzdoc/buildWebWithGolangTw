<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>02.3 | 使用 Golang 打造 Web 應用程式</title>


<link rel="stylesheet" href="/buildWebWithGolangTw/book.min.89885fa0429ec73067282f26fc0c6d38cfc617a443ec4e835d47b821c52c6e92.css" integrity="sha256-iYhfoEKexzBnKC8m/AxtOM/GF6RD7E6DXUe4IcUsbpI=">


<script defer src="/buildWebWithGolangTw/search.min.1a26f030063cd84b7dd0472b3e255bc21c62c31322ab49b56f536fba41b42496.js" integrity="sha256-GibwMAY82Et90EcrPiVbwhxiwxMiq0m1b1NvukG0JJY="></script>



<link rel="icon" href="/buildWebWithGolangTw/favicon.png" type="image/x-icon">

<base href="https://ezzdoc.com/buildWebWithGolangTw/">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://ezzdoc.com/buildWebWithGolangTw/"><span>使用 Golang 打造 Web 應用程式</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" readonly />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    
  
  
  

  <style>
  nav ul a[href$="\2f buildWebWithGolangTw\2f docs\2f 02.3\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/buildWebWithGolangTw/docs/preface/">目錄</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.0/">1.Go 環境配置</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/01.1/">1.1 安裝 Go</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.2/">1.2 GOPATH 與工作空間</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.3/">1.3 Go 命令</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.4/">1.4 Go 開發工具</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.5/">1.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/02.0/">2.Go 語言基礎</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/02.1/">2.1 你好，Go</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.2/">2.2 Go 基礎</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.3/">2.3 流程和函式</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.4/">2.4 struct</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.5/">2.5 物件導向</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.6/">2.6 interface</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.7/">2.7 併發</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.8/">2.8 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/03.0/">3.Web 基礎</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/03.1/">3.1 web 工作方式</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.2/">3.2 Go 建立一個簡單的 web 服務</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.3/">3.3 Go 如何使得 web 工作</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.4/">3.4 Go 的 http 套件詳解</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.5/">3.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/04.0/">4.表單</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/04.1/">4.1 處理表單的輸入</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.2/">4.2 驗證表單的輸入</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.3/">4.3 預防跨站指令碼</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.4/">4.4 防止多次提交表單</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.5/">4.5 處理檔案上傳</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.6/">4.6 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/05.0/">5.訪問資料庫</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/05.1/">5.1 database/sql 介面</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.2/">5.2 使用 MySQL 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.3/">5.3 使用 SQLite 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.4/">5.4 使用 PostgreSQL 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.5/">5.5 使用 Beego orm 函式庫進行 ORM 開發</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.6/">5.6 NOSQL 資料庫操作</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.7/">5.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/06.0/">6.session 和資料儲存</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/06.1/">6.1 session 和 cookie</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.2/">6.2 Go 如何使用 session</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.3/">6.3 session 儲存</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.4/">6.4 預防 session 劫持</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.5/">6.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/07.0/">7.文字檔案處理</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/07.1/">7.1 XML 處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.2/">7.2 JSON 處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.3/">7.3 正則處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.4/">7.4 範本處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.5/">7.5 檔案操作</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.6/">7.6 字串處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.7/">7.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/08.0/">8.Web 服務</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/08.1/">8.1 Socket 程式設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.2/">8.2 WebSocket</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.3/">8.3 REST</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.4/">8.4 RPC</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.5/">8.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/09.0/">9.安全與加密</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/09.1/">9.1 預防 CSRF 攻擊</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.2/">9.2 確保輸入過濾</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.3/">9.3 避免 XSS 攻擊</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.4/">9.4 避免 SQL 注入</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.5/">9.5 儲存密碼</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.6/">9.6 加密和解密資料</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.7/">9.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/10.0/">10.國際化和本地化</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/10.1/">10.1 設定預設地區</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.2/">10.2 本地化資源</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.3/">10.3 國際化站點</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.4/">10.4 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/11.0/">11.錯誤處理，除錯和測試</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/11.1/">11.1 錯誤處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.2/">11.2 使用 GDB 除錯</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.3/">11.3 Go 怎麼寫測試案例</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.4/">11.4 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/12.0/">12.部署與維護</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/12.1/">12.1 應用日誌</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.2/">12.2 網站錯誤處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.3/">12.3 應用部署</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.4/">12.4 備份和還原</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.5/">12.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/13.0/">13.如何設計一個 Web 框架</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/13.1/">13.1 專案規劃</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.2/">13.2 自訂路由器設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.3/">13.3 controller 設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.4/">13.4 日誌和配置設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.5/">13.5 實現部落格的增刪改</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.6/">13.6 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/14.0/">14.擴充套件 Web 框架</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/14.1/">14.1 靜態檔案支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.2/">14.2 Session 支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.3/">14.3 表單支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.4/">14.4 使用者認證</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.5/">14.5 多語言支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.6/">14.6 pprof 支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.7/">14.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/ref/">附錄 A 參考資料</a></li>
</ul>







</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/buildWebWithGolangTw/svg/menu.svg" alt="Menu" />
  </label>
  <strong>02.3</strong>
</header>

      
<article class="markdown">

<h1 id="2-3-流程和函式">2.3 流程和函式</h1>

<p>這小節我們要介紹 Go 裡面的流程控制以及函式操作。</p>

<h2 id="流程控制">流程控制</h2>

<p>流程控制在程式語言中是最偉大的發明了，因為有了它，你可以透過很簡單的流程描述來表達很複雜的邏輯。Go 中流程控制分三大類別：條件判斷，迴圈控制和無條件跳轉。</p>

<h3 id="if">if</h3>

<p><code>if</code>也許是各種程式語言中最常見的了，它的語法概括起來就是：如果滿足條件就做某事，否則做另一件事。</p>

<p>Go 裡面 <code>if</code> 條件判斷語句中不需要括號，如下程式碼所示</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> &gt; <span style="color:#ae81ff">10</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x is greater than 10&#34;</span>)
} <span style="color:#66d9ef">else</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x is less than 10&#34;</span>)
}</code></pre></div>
<p>Go 的 <code>if</code> 還有一個強大的地方就是條件判斷語句裡面允許宣告一個變數，這個變數的作用域只能在該條件邏輯區塊內，其他地方就無法使用，如下所示</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#75715e">// 計算取得值 x，然後根據 x 回傳的大小，判斷是否大於 10。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">computedValue</span>(); <span style="color:#a6e22e">x</span> &gt; <span style="color:#ae81ff">10</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x is greater than 10&#34;</span>)
} <span style="color:#66d9ef">else</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x is less than 10&#34;</span>)
}

<span style="color:#75715e">//這個地方如果這樣呼叫就編譯出錯了，因為 x 是條件裡面的變數
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span>)</code></pre></div>
<p>多個條件的時候如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">integer</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;The integer is equal to 3&#34;</span>)
} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">integer</span> &lt; <span style="color:#ae81ff">3</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;The integer is less than 3&#34;</span>)
} <span style="color:#66d9ef">else</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;The integer is greater than 3&#34;</span>)
}</code></pre></div>
<h3 id="goto">goto</h3>

<p>Go 有 <code>goto</code> 語句——請明智地使用它。用 <code>goto</code> 跳轉到必須在當前函式內定義的標籤。例如假設這樣一個迴圈：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myFunc</span>() {
	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
<span style="color:#a6e22e">Here</span>:   <span style="color:#75715e">//這行的第一個詞，以冒號結束作為標籤
</span><span style="color:#75715e"></span>	println(<span style="color:#a6e22e">i</span>)
	<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
	<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">Here</span>   <span style="color:#75715e">//跳轉到 Here 去
</span><span style="color:#75715e"></span>}</code></pre></div>
<blockquote>
<p>標籤名稱(label)是區分大小寫的的。</p>
</blockquote>

<h3 id="for">for</h3>

<p>Go 裡面最強大的一個控制邏輯就是<code>for</code>，它既可以用來迴圈讀取資料，又可以當作 <code>while</code> 來控制邏輯，還能迭代操作。它的語法如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">expression1</span>; <span style="color:#a6e22e">expression2</span>; <span style="color:#a6e22e">expression3</span> {
	<span style="color:#75715e">//...
</span><span style="color:#75715e"></span>}</code></pre></div>
<p><code>expression1</code>、<code>expression2</code>和 <code>expression3</code> 都是表示式，其中 <code>expression1</code> 和<code>expression3</code>是變數宣告或者函式呼叫回傳值之類別的，<code>expression2</code>是用來條件判斷，<code>expression1</code>在迴圈開始之前呼叫，<code>expression3</code>在每輪迴圈結束之時呼叫。</p>

<p>一個例子比上面講那麼多更有用，那麼我們看看下面的例子吧：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
	<span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">index</span> &lt; <span style="color:#ae81ff">10</span> ; <span style="color:#a6e22e">index</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">index</span>
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;sum is equal to &#34;</span>, <span style="color:#a6e22e">sum</span>)
}
<span style="color:#f92672">//</span> <span style="color:#a6e22e">輸出</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#a6e22e">sum</span> <span style="color:#a6e22e">is</span> <span style="color:#a6e22e">equal</span> <span style="color:#a6e22e">to</span> <span style="color:#ae81ff">45</span></code></pre></div>
<p>有些時候需要進行多個賦值操作，由於 Go 裡面沒有<code>,</code>運算子，那麼可以使用平行賦值<code>i, j = i+1, j-1</code></p>

<p>有些時候如果我們忽略 <code>expression1</code> 和<code>expression3</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">sum</span> &lt; <span style="color:#ae81ff">1000</span>;  {
	<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">sum</span>
}</code></pre></div>
<p>其中 <code>;</code> 也可以省略，那麼就變成如下的程式碼了，是不是似曾相識？對，這就是 <code>while</code> 的功能。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">sum</span> &lt; <span style="color:#ae81ff">1000</span> {
	<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">sum</span>
}</code></pre></div>
<p>在迴圈裡面有兩個關鍵操作 <code>break</code> 和<code>continue</code>    ,<code>break</code>操作是跳出當前迴圈，<code>continue</code>是跳過本次迴圈。當巢狀過深的時候，<code>break</code>可以配合標籤使用，即跳轉至標籤所指定的位置，詳細參考如下例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">index</span>&gt;<span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">index</span><span style="color:#f92672">--</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>{
		<span style="color:#66d9ef">break</span> <span style="color:#75715e">// 或者 continue
</span><span style="color:#75715e"></span>	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">index</span>)
}
<span style="color:#75715e">// break 顯示出來 10、9、8、7、6
</span><span style="color:#75715e"></span><span style="color:#f92672">//</span> <span style="color:#66d9ef">continue</span> <span style="color:#a6e22e">顯示出來</span> <span style="color:#ae81ff">10</span><span style="color:#960050;background-color:#1e0010">、</span><span style="color:#ae81ff">9</span><span style="color:#960050;background-color:#1e0010">、</span><span style="color:#ae81ff">8</span><span style="color:#960050;background-color:#1e0010">、</span><span style="color:#ae81ff">7</span><span style="color:#960050;background-color:#1e0010">、</span><span style="color:#ae81ff">6</span><span style="color:#960050;background-color:#1e0010">、</span><span style="color:#ae81ff">4</span><span style="color:#960050;background-color:#1e0010">、</span><span style="color:#ae81ff">3</span><span style="color:#960050;background-color:#1e0010">、</span><span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">、</span><span style="color:#ae81ff">1</span></code></pre></div>
<p><code>break</code>和 <code>continue</code> 還可以跟著標號，用來跳到多重迴圈中的外層迴圈</p>

<p><code>for</code>配合 <code>range</code> 可以用於讀取 <code>slice</code> 和<code>map</code>的資料：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>,<span style="color:#a6e22e">v</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">range</span> <span style="color:#66d9ef">map</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;map&#39;s key:&#34;</span>,<span style="color:#a6e22e">k</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;map&#39;s val:&#34;</span>,<span style="color:#a6e22e">v</span>)
}</code></pre></div>
<p>由於 Go 支援 “多值回傳”, 而對於“宣告而未被呼叫”的變數, 編譯器會報錯, 在這種情況下, 可以使用 <code>_</code> 來丟棄不需要的回傳值
例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#66d9ef">map</span>{
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;map&#39;s val:&#34;</span>, <span style="color:#a6e22e">v</span>)
}</code></pre></div>
<h3 id="switch">switch</h3>

<p>有些時候你需要寫很多的<code>if-else</code>來實現一些邏輯處理，這個時候程式碼看上去就很醜很冗長，而且也不易於以後的維護，這個時候 <code>switch</code> 就能很好的解決這個問題。它的語法如下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">sExpr</span> {
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">expr1</span>:
	<span style="color:#a6e22e">some</span> <span style="color:#a6e22e">instructions</span>
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">expr2</span>:
	<span style="color:#a6e22e">some</span> <span style="color:#a6e22e">other</span> <span style="color:#a6e22e">instructions</span>
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">expr3</span>:
	<span style="color:#a6e22e">some</span> <span style="color:#a6e22e">other</span> <span style="color:#a6e22e">instructions</span>
<span style="color:#66d9ef">default</span>:
	<span style="color:#a6e22e">other</span> <span style="color:#a6e22e">code</span>
}</code></pre></div>
<p><code>sExpr</code>和<code>expr1</code>、<code>expr2</code>、<code>expr3</code>的型別必須一致。Go 的 <code>switch</code> 非常靈活，表示式不必是常數或整數，執行的過程從上至下，直到找到匹配項；而如果 <code>switch</code> 沒有表示式，它會匹配<code>true</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span>
<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">i</span> {
<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span>:
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;i is equal to 1&#34;</span>)
<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>:
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;i is equal to 2, 3 or 4&#34;</span>)
<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">10</span>:
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;i is equal to 10&#34;</span>)
<span style="color:#66d9ef">default</span>:
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;All I know is that i is an integer&#34;</span>)
}</code></pre></div>
<p>在第 5 行中，我們把很多值聚合在了一個 <code>case</code> 裡面，同時，Go 裡面 <code>switch</code> 預設相當於每個 <code>case</code> 最後帶有<code>break</code>，匹配成功後不會自動向下執行其他 case，而是跳出整個<code>switch</code>, 但是可以使用 <code>fallthrough</code> 強制執行後面的 case 程式碼。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">integer</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">6</span>
<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">integer</span> {
<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">4</span>:
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;The integer was &lt;= 4&#34;</span>)
	<span style="color:#66d9ef">fallthrough</span>
<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">5</span>:
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;The integer was &lt;= 5&#34;</span>)
	<span style="color:#66d9ef">fallthrough</span>
<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">6</span>:
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;The integer was &lt;= 6&#34;</span>)
	<span style="color:#66d9ef">fallthrough</span>
<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">7</span>:
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;The integer was &lt;= 7&#34;</span>)
	<span style="color:#66d9ef">fallthrough</span>
<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">8</span>:
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;The integer was &lt;= 8&#34;</span>)
	<span style="color:#66d9ef">fallthrough</span>
<span style="color:#66d9ef">default</span>:
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;default case&#34;</span>)
}</code></pre></div>
<p>上面的程式將輸出</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">The</span> <span style="color:#a6e22e">integer</span> <span style="color:#a6e22e">was</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">6</span>
<span style="color:#a6e22e">The</span> <span style="color:#a6e22e">integer</span> <span style="color:#a6e22e">was</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">7</span>
<span style="color:#a6e22e">The</span> <span style="color:#a6e22e">integer</span> <span style="color:#a6e22e">was</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">8</span>
<span style="color:#66d9ef">default</span> <span style="color:#66d9ef">case</span></code></pre></div>
<h2 id="函式">函式</h2>

<p>函式是 Go 裡面的核心設計，它透過關鍵字 <code>func</code> 來宣告，它的格式如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">funcName</span>(<span style="color:#a6e22e">input1</span> <span style="color:#a6e22e">type1</span>, <span style="color:#a6e22e">input2</span> <span style="color:#a6e22e">type2</span>) (<span style="color:#a6e22e">output1</span> <span style="color:#a6e22e">type1</span>, <span style="color:#a6e22e">output2</span> <span style="color:#a6e22e">type2</span>) {
	<span style="color:#75715e">//這裡是處理邏輯程式碼
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//回傳多個值
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">value1</span>, <span style="color:#a6e22e">value2</span>
}</code></pre></div>
<p>上面的程式碼我們看出</p>

<ul>
<li>關鍵字 <code>func</code> 用來宣告一個函式<code>funcName</code></li>
<li>函式可以有一個或者多個參數，每個參數後面帶有型別，透過<code>,</code>分隔</li>
<li>函式可以回傳多個值</li>
<li>上面回傳值宣告了兩個變數 <code>output1</code> 和<code>output2</code>，如果你不想宣告也可以，直接就兩個型別</li>
<li>如果只有一個回傳值且不宣告回傳值變數，那麼你可以省略 包括回傳值 的括號</li>
<li>如果沒有回傳值，那麼就直接省略最後的回傳資訊</li>
<li>如果有回傳值， 那麼必須在函式的外層新增 return 語句</li>
</ul>

<p>下面我們來看一個實際應用函式的例子（用來計算 Max 值）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">// 回傳 a、b 中最大值.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &gt; <span style="color:#a6e22e">b</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3</span>
	<span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">4</span>
	<span style="color:#a6e22e">z</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">5</span>

	<span style="color:#a6e22e">max_xy</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) <span style="color:#75715e">//呼叫函式 max(x, y)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">max_xz</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">z</span>) <span style="color:#75715e">//呼叫函式 max(x, z)
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;max(%d, %d) = %d\n&#34;</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">max_xy</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;max(%d, %d) = %d\n&#34;</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">z</span>, <span style="color:#a6e22e">max_xz</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;max(%d, %d) = %d\n&#34;</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span>, <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">y</span>,<span style="color:#a6e22e">z</span>)) <span style="color:#75715e">// 也可在這直接呼叫它
</span><span style="color:#75715e"></span>}</code></pre></div>
<p>上面這個裡面我們可以看到 <code>max</code> 函式有兩個參數，它們的型別都是<code>int</code>，那麼第一個變數的型別可以省略（即 a,b int，而非 a int, b int)，預設為離它最近的型別，同理多於 2 個同類型的變數或者回傳值。同時我們注意到它的回傳值就是一個型別，這個就是省略寫法。</p>

<h3 id="多個回傳值">多個回傳值</h3>

<p>Go 語言比 C 更先進的特性，其中一點就是函式能夠回傳多個值。</p>

<p>我們直接上程式碼看例子</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">//回傳 A+B 和 A*B
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">SumAndProduct</span>(<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">A</span><span style="color:#f92672">+</span><span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">A</span><span style="color:#f92672">*</span><span style="color:#a6e22e">B</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3</span>
	<span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">4</span>

	<span style="color:#a6e22e">xPLUSy</span>, <span style="color:#a6e22e">xTIMESy</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">SumAndProduct</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d + %d = %d\n&#34;</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">xPLUSy</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d * %d = %d\n&#34;</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">xTIMESy</span>)
}</code></pre></div>
<p>上面的例子我們可以看到直接回傳了兩個參數，當然我們也可以命名回傳參數的變數，這個例子裡面只是用了兩個型別，我們也可以改成如下這樣的定義，然後回傳的時候不用帶上變數名，因為直接在函式裡面初始化了。但如果你的函式是匯出的(首字母大寫)，官方建議：最好命名回傳值，因為不命名回傳值，雖然使得程式碼更加簡潔了，但是會造成產生的文件可讀性差。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">SumAndProduct</span>(<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">add</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">Multiplied</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">add</span> = <span style="color:#a6e22e">A</span><span style="color:#f92672">+</span><span style="color:#a6e22e">B</span>
	<span style="color:#a6e22e">Multiplied</span> = <span style="color:#a6e22e">A</span><span style="color:#f92672">*</span><span style="color:#a6e22e">B</span>
	<span style="color:#66d9ef">return</span>
}</code></pre></div>
<h3 id="可變參數函式-variadic-functions">可變參數函式 (Variadic functions)</h3>

<p>Go 函式支援可變參數函式。接受可變參數的函式是有著不定數量的參數的。為了做到這點，首先需要定義函式使其接受可變參數：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">arg</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">int</span>) {}</code></pre></div>
<p><code>arg ...int</code> 告訴 Go 這個函式接受不定數量的參數。注意，這些參數的型別全部是 <code>int</code>。在函式體中，變數 <code>arg</code> 是一個 <code>int</code> 的 <code>slice</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">arg</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;And the number is: %d\n&#34;</span>, <span style="color:#a6e22e">n</span>)
}</code></pre></div>
<h3 id="傳值與傳指標">傳值與傳指標</h3>

<p>當我們傳一個參數值到被呼叫函式裡面時，實際上是傳了這個值的一份 copy，當在被呼叫函式中修改參數值的時候，呼叫函式中相應參數不會發生任何變化，因為數值變化只作用在 copy 上。</p>

<p>為了驗證我們上面的說法，我們來看一個例子</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">//簡單的一個函式，實現了參數+1 的操作
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add1</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">a</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#75715e">// 我們改變了 a 的值
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#75715e">//回傳一個新值
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x = &#34;</span>, <span style="color:#a6e22e">x</span>)  <span style="color:#75715e">// 應該輸出 &#34;x = 3&#34;
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">x1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">add1</span>(<span style="color:#a6e22e">x</span>)  <span style="color:#75715e">//呼叫 add1(x)
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x+1 = &#34;</span>, <span style="color:#a6e22e">x1</span>) <span style="color:#75715e">// 應該輸出&#34;x+1 = 4&#34;
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x = &#34;</span>, <span style="color:#a6e22e">x</span>)    <span style="color:#75715e">// 應該輸出&#34;x = 3&#34;
</span><span style="color:#75715e"></span>}</code></pre></div>
<p>看到了嗎？雖然我們呼叫了 <code>add1</code> 函式，並且在 <code>add1</code> 中執行<code>a = a+1</code>操作，但是上面例子中 <code>x</code> 變數的值沒有發生變化</p>

<p>理由很簡單：因為當我們呼叫 <code>add1</code> 的時候，<code>add1</code>接收的參數其實是 <code>x</code> 的 copy，而不是 <code>x</code> 本身。</p>

<p>那你也許會問了，如果真的需要傳這個 <code>x</code> 本身，該怎麼辦呢？</p>

<p>這就牽扯到了所謂的指標。我們知道，變數在記憶體中是存放於一定地址上的，修改變數實際是修改變數地址處的記憶體。只有 <code>add1</code> 函式知道 <code>x</code> 變數所在的地址，才能修改 <code>x</code> 變數的值。所以我們需要將 <code>x</code> 所在地址<code>&amp;x</code>傳入函式，並將函式的參數的型別由 <code>int</code> 改為<code>*int</code>，即改為指標型別，才能在函式中修改 <code>x</code> 變數的值。此時參數仍然是按 copy 傳遞的，只是 copy 的是一個指標。請看下面的例子</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">//簡單的一個函式，實現了參數+1 的操作
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add1</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> { <span style="color:#75715e">// 請注意，
</span><span style="color:#75715e"></span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">a</span> = <span style="color:#f92672">*</span><span style="color:#a6e22e">a</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#75715e">// 修改了 a 的值
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">a</span> <span style="color:#75715e">// 回傳新值
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x = &#34;</span>, <span style="color:#a6e22e">x</span>)  <span style="color:#75715e">// 應該輸出 &#34;x = 3&#34;
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">x1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">add1</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">x</span>)  <span style="color:#75715e">// 呼叫 add1(&amp;x) 傳 x 的地址
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x+1 = &#34;</span>, <span style="color:#a6e22e">x1</span>) <span style="color:#75715e">// 應該輸出 &#34;x+1 = 4&#34;
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x = &#34;</span>, <span style="color:#a6e22e">x</span>)    <span style="color:#75715e">// 應該輸出 &#34;x = 4&#34;
</span><span style="color:#75715e"></span>}</code></pre></div>
<p>這樣，我們就達到了修改 <code>x</code> 的目的。那麼到底傳指標有什麼好處呢？</p>

<ul>
<li>傳指標使得多個函式能操作同一個物件。</li>
<li>傳指標比較輕量級 (8bytes)，只是傳記憶體地址，我們可以用指標傳遞體積大的結構體。如果用參數值傳遞的話, 在每次 copy 上面就會花費相對較多的系統開銷（記憶體和時間）。所以當你要傳遞大的結構體的時候，用指標是一個明智的選擇。</li>
<li>Go 語言中<code>channel</code>，<code>slice</code>，<code>map</code>這三種類型的實現機制類似指標，所以可以直接傳遞，而不用取地址後傳遞指標。（注：若函式需改變 <code>slice</code> 的長度，則仍需要取地址傳遞指標）</li>
</ul>

<h3 id="defer">defer</h3>

<p>Go 語言中有種不錯的設計，即延遲（defer）語句，你可以在函式中新增多個 defer 語句。當函式執行到最後時，這些 defer 語句會按照逆序執行，最後該函式回傳。特別是當你在進行一些開啟資源的操作時，遇到錯誤需要提前回傳，在回傳前你需要關閉相應的資源，不然很容易造成資源洩露等問題。如下程式碼所示，我們一般寫開啟一個資源是這樣操作的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ReadWrite</span>() <span style="color:#66d9ef">bool</span> {
	<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Open</span>(<span style="color:#e6db74">&#34;file&#34;</span>)
<span style="color:#75715e">// 做一些工作
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">failureX</span> {
		<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Close</span>()
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">failureY</span> {
		<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Close</span>()
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
	}

	<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Close</span>()
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}</code></pre></div>
<p>我們看到上面有很多重複的程式碼，Go 的 <code>defer</code> 有效解決了這個問題。使用它後，不但程式碼量減少了很多，而且程式變得更優雅。在 <code>defer</code> 後指定的函式會在函式退出前呼叫。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ReadWrite</span>() <span style="color:#66d9ef">bool</span> {
	<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Open</span>(<span style="color:#e6db74">&#34;file&#34;</span>)
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Close</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">failureX</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">failureY</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}</code></pre></div>
<p>如果有很多呼叫<code>defer</code>，那麼 <code>defer</code> 是採用後進先出模式，所以如下程式碼會輸出<code>4 3 2 1 0</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, <span style="color:#a6e22e">i</span>)
}</code></pre></div>
<h3 id="函式作為值-型別">函式作為值、型別</h3>

<p>在 Go 中函式也是一種變數，我們可以透過 <code>type</code> 來定義它，它的型別就是所有擁有相同的參數，相同的回傳值的一種型別</p>

<pre><code>type typeName func(input1 inputType1 , input2 inputType2 [, ...]) (result1 resultType1 [, ...])
</code></pre>

<p>函式作為型別到底有什麼好處呢？那就是可以把這個型別的函式當做值來傳遞，請看下面的例子</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">testInt</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// 宣告了一個函式型別
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isOdd</span>(<span style="color:#a6e22e">integer</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">integer</span><span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isEven</span>(<span style="color:#a6e22e">integer</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">integer</span><span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
}

<span style="color:#75715e">// 宣告的函式型別在這個地方當做了一個參數
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">filter</span>(<span style="color:#a6e22e">slice</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">f</span> <span style="color:#a6e22e">testInt</span>) []<span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">result</span> []<span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">slice</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">value</span>) {
			<span style="color:#a6e22e">result</span> = append(<span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">value</span>)
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
	<span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;slice = &#34;</span>, <span style="color:#a6e22e">slice</span>)
	<span style="color:#a6e22e">odd</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">filter</span>(<span style="color:#a6e22e">slice</span>, <span style="color:#a6e22e">isOdd</span>)    <span style="color:#75715e">// 函式當做值來傳遞了
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Odd elements of slice are: &#34;</span>, <span style="color:#a6e22e">odd</span>)
	<span style="color:#a6e22e">even</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">filter</span>(<span style="color:#a6e22e">slice</span>, <span style="color:#a6e22e">isEven</span>)  <span style="color:#75715e">// 函式當做值來傳遞了
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Even elements of slice are: &#34;</span>, <span style="color:#a6e22e">even</span>)
}</code></pre></div>
<p>函式當做值和型別在我們寫一些通用介面的時候非常有用，透過上面例子我們看到 <code>testInt</code> 這個型別是一個函式型別，然後兩個 <code>filter</code> 函式的參數和回傳值與 <code>testInt</code> 型別是一樣的，但是我們可以實現很多種的邏輯，這樣使得我們的程式變得非常的靈活。</p>

<h3 id="panic-和-recover">Panic 和 Recover</h3>

<p>Go 沒有像 Java 那樣的異常機制，它不能丟擲異常，而是使用了 <code>panic</code> 和<code>recover</code>機制。一定要記住，你應當把它作為最後的手段來使用，也就是說，你的程式碼中應當沒有，或者很少有 <code>panic</code> 的東西。這是個強大的工具，請明智地使用它。那麼，我們應該如何使用它呢？</p>

<p>Panic
&gt;是一個內建函式，可以中斷原有的控制流程，進入一個 <code>panic</code> 狀態中。當函式 <code>F</code> 呼叫<code>panic</code>，函式 F 的執行被中斷，但是 <code>F</code> 中的延遲函式會正常執行，然後 F 回傳到呼叫它的地方。在呼叫的地方，<code>F</code>的行為就像呼叫了<code>panic</code>。這一過程繼續向上，直到發生 <code>panic</code> 的<code>goroutine</code>中所有呼叫的函式回傳，此時程式退出。<code>panic</code>可以直接呼叫 <code>panic</code> 產生。也可以由執行時錯誤產生，例如訪問越界的陣列。</p>

<p>Recover
&gt;是一個內建的函式，可以讓進入 <code>panic</code> 狀態的 <code>goroutine</code> 恢復過來。<code>recover</code>僅在延遲函式中有效。在正常的執行過程中，呼叫 <code>recover</code> 會回傳<code>nil</code>，並且沒有其它任何效果。如果當前的 <code>goroutine</code> 陷入 <code>panic</code> 狀態，呼叫 <code>recover</code> 可以捕獲到 <code>panic</code> 的輸入值，並且恢復正常的執行。</p>

<p>下面這個函式示範了如何在過程中使用<code>panic</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">user</span> = <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getenv</span>(<span style="color:#e6db74">&#34;USER&#34;</span>)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">init</span>() {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> {
		panic(<span style="color:#e6db74">&#34;no value for $USER&#34;</span>)
	}
}</code></pre></div>
<p>下面這個函式檢查作為其參數的函式在執行時是否會產生<code>panic</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">throwsPanic</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>()) (<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">bool</span>) {
	<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> recover(); <span style="color:#a6e22e">x</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">b</span> = <span style="color:#66d9ef">true</span>
		}
	}()
	<span style="color:#a6e22e">f</span>() <span style="color:#75715e">//執行函式 f，如果 f 中出現了 panic，那麼就可以恢復回來
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span>
}</code></pre></div>
<h3 id="main-函式和-init-函式"><code>main</code>函式和 <code>init</code> 函式</h3>

<p>Go 裡面有兩個保留的函式：<code>init</code>函式（能夠應用於所有的<code>package</code>）和 <code>main</code> 函式（只能應用於<code>package main</code>）。這兩個函式在定義時不能有任何的參數和回傳值。雖然一個 <code>package</code> 裡面可以寫任意多個 <code>init</code> 函式，但這無論是對於可讀性還是以後的可維護性來說，我們都強烈建議使用者在一個 <code>package</code> 中每個檔案只寫一個 <code>init</code> 函式。</p>

<p>Go 程式會自動呼叫<code>init()</code>和<code>main()</code>，所以你不需要在任何地方呼叫這兩個函式。每個 <code>package</code> 中的 <code>init</code> 函式都是可選的，但<code>package main</code>就必須包含一個 <code>main</code> 函式。</p>

<p>程式的初始化和執行都起始於 <code>main</code> 套件。如果 <code>main</code> 套件還匯入了其它的套件，那麼就會在編譯時將它們依次匯入。有時一個套件會被多個套件同時匯入，那麼它只會被匯入一次（例如很多套件可能都會用到 <code>fmt</code> 套件，但它只會被匯入一次，因為沒有必要匯入多次）。當一個套件被匯入時，如果該套件還匯入了其它的套件，那麼會先將其它套件匯入進來，然後再對這些套件中的 &ldquo;套件級&rdquo; (package-level) 常數和變數進行初始化，接著執行 <code>init</code> 函式（如果有的話），依次類別推。等所有被匯入的套件都載入完畢了，就會開始對 <code>main</code> 套件中的 &ldquo;套件級&rdquo; 常數和變數進行初始化，然後執行 <code>main</code> 套件中的 <code>init</code> 函式（如果存在的話），最後執行 <code>main</code> 函式。下圖詳細地解釋了整個執行過程：</p>

<p><img src="images/2.3.init.png" alt="" /></p>

<p>圖 2.6 main 函式引入套件初始化流程圖</p>

<h3 id="import">import</h3>

<p>我們在寫 Go 程式碼的時候經常用到 import 這個命令用來匯入套件檔案，而我們經常看到的方式參考如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">import</span>(
    <span style="color:#e6db74">&#34;fmt&#34;</span>
)</code></pre></div>
<p>然後我們程式碼裡面可以透過如下的方式呼叫</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;hello world&#34;</span>)</code></pre></div>
<p>上面這個 fmt 是 Go 語言的標準函式庫，其實是去 <code>GOROOT</code> 環境變數指定目錄下去載入該模組，當然 Go 的 import 還支援如下兩種方式來載入自己寫的模組：</p>

<ol>
<li><p>相對路徑</p>

<p>import “./model” //當前檔案同一目錄的 model 目錄，但是不建議這種方式來 import</p></li>

<li><p>絕對路徑</p>

<p>import “shorturl/model” //載入 gopath/src/shorturl/model 模組</p></li>
</ol>

<p>上面展示了一些 import 常用的幾種方式，但是還有一些特殊的 import，讓很多新手很難以理解，下面我們來一一講解一下到底是怎麼一回事</p>

<ol>
<li><p>點操作</p>

<p>我們有時候會看到如下的方式匯入包</p>

<pre><code>import(
    . &quot;fmt&quot;
)
</code></pre>

<p>這個點操作的含義就是這個套件匯入之後在你呼叫這個套件的函式時，你可以省略字首的套件名，也就是前面你呼叫的 fmt.Println(&ldquo;hello world&rdquo;)可以省略的寫成 Println(&ldquo;hello world&rdquo;)</p></li>

<li><p>別名操作</p>

<p>別名操作顧名思義我們可以把套件命名成另一個我們用起來容易記憶的名字</p>

<pre><code>import(
    f &quot;fmt&quot;
)
</code></pre>

<p>別名操作的話呼叫套件函式時字首變成了我們的字首，即 f.Println(&ldquo;hello world&rdquo;)</p></li>

<li><p>_操作</p>

<p>這個操作經常是讓很多人難以理解的一個運算子，請看下面這個 import</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go">	<span style="color:#f92672">import</span> (
	    <span style="color:#e6db74">&#34;database/sql&#34;</span>
	    <span style="color:#a6e22e">_</span> <span style="color:#e6db74">&#34;github.com/ziutek/mymysql/godrv&#34;</span>
	)</code></pre></div>
<p>_操作其實是引入該套件，而不直接使用套件裡面的函式，而是呼叫了該套件裡面的 init 函式。</p></li>
</ol>

<h2 id="links">links</h2>

<ul>
<li><a href="docs/preface">目錄</a></li>
<li>上一章: <a href="docs/02.2">Go 基礎</a></li>
<li>下一節: <a href="docs/02.4">struct 型別</a></li>
</ul>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="/commit/fda25aafea9413c8ec77f5df29d5f6bb5f7dc3a6" title='Last modified Sep 21, 2019 by Jiuxiao' target="_blank" rel="noopener">
      <img src="/buildWebWithGolangTw/svg/calendar.svg" alt="Changed" /> Sep 21, 2019
    </a>
  </div>
  
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-3 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#2-3-流程和函式">2.3 流程和函式</a>
<ul>
<li><a href="#流程控制">流程控制</a>
<ul>
<li><a href="#if">if</a></li>
<li><a href="#goto">goto</a></li>
<li><a href="#for">for</a></li>
<li><a href="#switch">switch</a></li>
</ul></li>
<li><a href="#函式">函式</a>
<ul>
<li><a href="#多個回傳值">多個回傳值</a></li>
<li><a href="#可變參數函式-variadic-functions">可變參數函式 (Variadic functions)</a></li>
<li><a href="#傳值與傳指標">傳值與傳指標</a></li>
<li><a href="#defer">defer</a></li>
<li><a href="#函式作為值-型別">函式作為值、型別</a></li>
<li><a href="#panic-和-recover">Panic 和 Recover</a></li>
<li><a href="#main-函式和-init-函式"><code>main</code>函式和 <code>init</code> 函式</a></li>
<li><a href="#import">import</a></li>
</ul></li>
<li><a href="#links">links</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-148025936-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>

</html>
