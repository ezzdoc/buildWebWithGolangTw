<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>07.2 | 使用 Golang 打造 Web 應用程式</title>


<link rel="stylesheet" href="/buildWebWithGolangTw/book.min.89885fa0429ec73067282f26fc0c6d38cfc617a443ec4e835d47b821c52c6e92.css" integrity="sha256-iYhfoEKexzBnKC8m/AxtOM/GF6RD7E6DXUe4IcUsbpI=">


<script defer src="/buildWebWithGolangTw/search.min.1a26f030063cd84b7dd0472b3e255bc21c62c31322ab49b56f536fba41b42496.js" integrity="sha256-GibwMAY82Et90EcrPiVbwhxiwxMiq0m1b1NvukG0JJY="></script>



<link rel="icon" href="/buildWebWithGolangTw/favicon.png" type="image/x-icon">

<base href="https://ezzdoc.com/buildWebWithGolangTw/">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://ezzdoc.com/buildWebWithGolangTw/"><span>使用 Golang 打造 Web 應用程式</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" readonly />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    
  
  
  

  <style>
  nav ul a[href$="\2f buildWebWithGolangTw\2f docs\2f 07.2\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/buildWebWithGolangTw/docs/preface/">目錄</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.0/">1.Go 環境配置</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/01.1/">1.1 安裝 Go</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.2/">1.2 GOPATH 與工作空間</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.3/">1.3 Go 命令</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.4/">1.4 Go 開發工具</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.5/">1.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/02.0/">2.Go 語言基礎</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/02.1/">2.1 你好，Go</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.2/">2.2 Go 基礎</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.3/">2.3 流程和函式</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.4/">2.4 struct</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.5/">2.5 物件導向</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.6/">2.6 interface</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.7/">2.7 併發</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.8/">2.8 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/03.0/">3.Web 基礎</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/03.1/">3.1 web 工作方式</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.2/">3.2 Go 建立一個簡單的 web 服務</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.3/">3.3 Go 如何使得 web 工作</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.4/">3.4 Go 的 http 套件詳解</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.5/">3.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/04.0/">4.表單</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/04.1/">4.1 處理表單的輸入</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.2/">4.2 驗證表單的輸入</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.3/">4.3 預防跨站指令碼</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.4/">4.4 防止多次提交表單</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.5/">4.5 處理檔案上傳</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.6/">4.6 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/05.0/">5.訪問資料庫</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/05.1/">5.1 database/sql 介面</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.2/">5.2 使用 MySQL 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.3/">5.3 使用 SQLite 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.4/">5.4 使用 PostgreSQL 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.5/">5.5 使用 Beego orm 函式庫進行 ORM 開發</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.6/">5.6 NOSQL 資料庫操作</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.7/">5.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/06.0/">6.session 和資料儲存</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/06.1/">6.1 session 和 cookie</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.2/">6.2 Go 如何使用 session</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.3/">6.3 session 儲存</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.4/">6.4 預防 session 劫持</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.5/">6.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/07.0/">7.文字檔案處理</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/07.1/">7.1 XML 處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.2/">7.2 JSON 處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.3/">7.3 正則處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.4/">7.4 範本處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.5/">7.5 檔案操作</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.6/">7.6 字串處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.7/">7.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/08.0/">8.Web 服務</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/08.1/">8.1 Socket 程式設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.2/">8.2 WebSocket</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.3/">8.3 REST</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.4/">8.4 RPC</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.5/">8.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/09.0/">9.安全與加密</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/09.1/">9.1 預防 CSRF 攻擊</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.2/">9.2 確保輸入過濾</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.3/">9.3 避免 XSS 攻擊</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.4/">9.4 避免 SQL 注入</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.5/">9.5 儲存密碼</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.6/">9.6 加密和解密資料</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.7/">9.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/10.0/">10.國際化和本地化</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/10.1/">10.1 設定預設地區</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.2/">10.2 本地化資源</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.3/">10.3 國際化站點</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.4/">10.4 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/11.0/">11.錯誤處理，除錯和測試</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/11.1/">11.1 錯誤處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.2/">11.2 使用 GDB 除錯</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.3/">11.3 Go 怎麼寫測試案例</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.4/">11.4 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/12.0/">12.部署與維護</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/12.1/">12.1 應用日誌</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.2/">12.2 網站錯誤處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.3/">12.3 應用部署</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.4/">12.4 備份和還原</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.5/">12.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/13.0/">13.如何設計一個 Web 框架</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/13.1/">13.1 專案規劃</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.2/">13.2 自訂路由器設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.3/">13.3 controller 設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.4/">13.4 日誌和配置設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.5/">13.5 實現部落格的增刪改</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.6/">13.6 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/14.0/">14.擴充套件 Web 框架</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/14.1/">14.1 靜態檔案支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.2/">14.2 Session 支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.3/">14.3 表單支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.4/">14.4 使用者認證</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.5/">14.5 多語言支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.6/">14.6 pprof 支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.7/">14.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/ref/">附錄 A 參考資料</a></li>
</ul>







</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/buildWebWithGolangTw/svg/menu.svg" alt="Menu" />
  </label>
  <strong>07.2</strong>
</header>

      
<article class="markdown">

<h1 id="7-2-json-處理">7.2 JSON 處理</h1>

<p>JSON（Javascript Object Notation）是一種輕量級的資料交換語言，以文字為基礎，具有自我描述性且易於讓人閱讀。儘管 JSON 是 Javascript 的一個子集，但 JSON 是獨立於語言的文字格式，並且採用了類似於 C 語言家族的一些習慣。JSON 與 XML 最大的不同在於 XML 是一個完整的標記語言，而 JSON 不是。JSON 由於比 XML 更小、更快，更易解析，以及瀏覽器的內建快速解析支援，使得其更適用於網路資料傳輸領域。目前我們看到很多的開放平臺，基本上都是採用了 JSON 作為他們的資料互動的介面。既然 JSON 在 Web 開發中如此重要，那麼 Go 語言對 JSON 支援的怎麼樣呢？Go 語言的標準函式庫已經非常好的支援了 JSON，可以很容易的對 JSON 資料進行編、解碼的工作。</p>

<p>前一小節的運維的例子用 json 來表示，結果描述如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#f92672">&#34;servers&#34;</span>:[{<span style="color:#f92672">&#34;serverName&#34;</span>:<span style="color:#e6db74">&#34;Shanghai_VPN&#34;</span>,<span style="color:#f92672">&#34;serverIP&#34;</span>:<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>},{<span style="color:#f92672">&#34;serverName&#34;</span>:<span style="color:#e6db74">&#34;Beijing_VPN&#34;</span>,<span style="color:#f92672">&#34;serverIP&#34;</span>:<span style="color:#e6db74">&#34;127.0.0.2&#34;</span>}]}</code></pre></div>
<p>本小節餘下的內容將以此 JSON 資料為基礎，來介紹 go 語言的 json 套件對 JSON 資料的編、解碼。</p>

<h2 id="解析-json">解析 JSON</h2>

<h3 id="解析到結構體">解析到結構體</h3>

<p>假如有了上面的 JSON 串，那麼我們如何來解析這個 JSON 串呢？Go 的 JSON 套件中有如下函式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">data</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">error</span></code></pre></div>
<p>透過這個函式我們就可以實現解析的目的，詳細的解析例子請看如下程式碼：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;encoding/json&#34;</span>
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Server</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">ServerName</span> <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">ServerIP</span>   <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Serverslice</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Servers</span> []<span style="color:#a6e22e">Server</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#a6e22e">Serverslice</span>
	<span style="color:#a6e22e">str</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">`{&#34;servers&#34;:[{&#34;serverName&#34;:&#34;Shanghai_VPN&#34;,&#34;serverIP&#34;:&#34;127.0.0.1&#34;},{&#34;serverName&#34;:&#34;Beijing_VPN&#34;,&#34;serverIP&#34;:&#34;127.0.0.2&#34;}]}`</span>
	<span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>([]byte(<span style="color:#a6e22e">str</span>), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
}</code></pre></div>
<p>在上面的範例程式碼中，我們首先定義了與 json 資料對應的結構體，陣列對應 slice，欄位名對應 JSON 裡面的 KEY，在解析的時候，如何將 json 資料與 struct 欄位相匹配呢？例如 JSON 的 key 是<code>Foo</code>，那麼怎麼找對應的欄位呢？</p>

<ul>
<li>首先查詢 tag 含有 <code>Foo</code> 的可匯出的 struct 欄位(首字母大寫)</li>
<li>其次查詢欄位名是 <code>Foo</code> 的匯出欄位</li>
<li>最後查詢類似 <code>FOO</code> 或者 <code>FoO</code> 這樣的除了首字母之外其他大小寫不敏感的匯出欄位</li>
</ul>

<p>聰明的你一定注意到了這一點：能夠被賦值的欄位必須是可匯出欄位(即首字母大寫）。同時 JSON 解析的時候只會解析能找得到的欄位，找不到的欄位會被忽略，這樣的一個好處是：當你接收到一個很大的 JSON 資料結構而你卻只想取得其中的部分資料的時候，你只需將你想要的資料對應的欄位名大寫，即可輕鬆解決這個問題。</p>

<h3 id="解析到-interface">解析到 interface</h3>

<p>上面那種解析方式是在我們知曉被解析的 JSON 資料的結構的前提下采取的方案，如果我們不知道被解析的資料的格式，又應該如何來解析呢？</p>

<p>我們知道 interface{} 可以用來儲存任意資料型別的物件，這種資料結構正好用於儲存解析的未知結構的 json 資料的結果。JSON 套件中採用 map[string]interface{} 和[]interface{}結構來儲存任意的 JSON 物件和陣列。Go 型別和 JSON 型別的對應關係如下：</p>

<ul>
<li>bool 代表 JSON booleans,</li>
<li>float64 代表 JSON numbers,</li>
<li>string 代表 JSON strings,</li>
<li>nil 代表 JSON null.</li>
</ul>

<p>現在我們假設有如下的 JSON 資料</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#e6db74">`{&#34;Name&#34;:&#34;Wednesday&#34;,&#34;Age&#34;:6,&#34;Parents&#34;:[&#34;Gomez&#34;,&#34;Morticia&#34;]}`</span>)</code></pre></div>
<p>如果在我們不知道他的結構的情況下，我們把他解析到 interface{} 裡面</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">interface</span>{}
<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">b</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">f</span>)</code></pre></div>
<p>這個時候 f 裡面儲存了一個 map 型別，他們的 key 是 string，值儲存在空的 interface{} 裡</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">f</span> = <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{
	<span style="color:#e6db74">&#34;Name&#34;</span>: <span style="color:#e6db74">&#34;Wednesday&#34;</span>,
	<span style="color:#e6db74">&#34;Age&#34;</span>:  <span style="color:#ae81ff">6</span>,
	<span style="color:#e6db74">&#34;Parents&#34;</span>: []<span style="color:#66d9ef">interface</span>{}{
		<span style="color:#e6db74">&#34;Gomez&#34;</span>,
		<span style="color:#e6db74">&#34;Morticia&#34;</span>,
	},
}</code></pre></div>
<p>那麼如何來訪問這些資料呢？透過斷言的方式：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>.(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{})</code></pre></div>
<p>透過斷言之後，你就可以透過如下方式來訪問裡面的資料了</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span> {
	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">vv</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">v</span>.(<span style="color:#66d9ef">type</span>) {
	<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">string</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">k</span>, <span style="color:#e6db74">&#34;is string&#34;</span>, <span style="color:#a6e22e">vv</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">int</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">k</span>, <span style="color:#e6db74">&#34;is int&#34;</span>, <span style="color:#a6e22e">vv</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">float64</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">k</span>,<span style="color:#e6db74">&#34;is float64&#34;</span>,<span style="color:#a6e22e">vv</span>)
	<span style="color:#66d9ef">case</span> []<span style="color:#66d9ef">interface</span>{}:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">k</span>, <span style="color:#e6db74">&#34;is an array:&#34;</span>)
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">u</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">vv</span> {
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">u</span>)
		}
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">k</span>, <span style="color:#e6db74">&#34;is of a type I don&#39;t know how to handle&#34;</span>)
	}
}</code></pre></div>
<p>透過上面的範例可以看到，透過 interface{} 與 type assert 的配合，我們就可以解析未知結構的 JSON 數了。</p>

<p>上面這個是官方提供的解決方案，其實很多時候我們透過型別斷言，操作起來不是很方便，目前 bitly 公司開源了一個叫做 <code>simplejson</code> 的套件，在處理未知結構體的 JSON 時相當方便，詳細例子如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">js</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewJson</span>([]byte(<span style="color:#e6db74">`{
</span><span style="color:#e6db74">	&#34;test&#34;: {
</span><span style="color:#e6db74">		&#34;array&#34;: [1, &#34;2&#34;, 3],
</span><span style="color:#e6db74">		&#34;int&#34;: 10,
</span><span style="color:#e6db74">		&#34;float&#34;: 5.150,
</span><span style="color:#e6db74">		&#34;bignum&#34;: 9223372036854775807,
</span><span style="color:#e6db74">		&#34;string&#34;: &#34;simplejson&#34;,
</span><span style="color:#e6db74">		&#34;bool&#34;: true
</span><span style="color:#e6db74">	}
</span><span style="color:#e6db74">}`</span>))

<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">js</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;test&#34;</span>).<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;array&#34;</span>).<span style="color:#a6e22e">Array</span>()
<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">js</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;test&#34;</span>).<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;int&#34;</span>).<span style="color:#a6e22e">Int</span>()
<span style="color:#a6e22e">ms</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">js</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;test&#34;</span>).<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;string&#34;</span>).<span style="color:#a6e22e">MustString</span>()</code></pre></div>
<p>可以看到，使用這個函式庫操作 JSON 比起官方套件來說，簡單的多，詳細的請參考如下地址：<a href="https://github.com/bitly/go-simplejson">https://github.com/bitly/go-simplejson</a></p>

<h2 id="產生-json">產生 JSON</h2>

<p>我們開發很多應用的時候，最後都是要輸出 JSON 資料串，那麼如何來處理呢？JSON 套件裡面透過 <code>Marshal</code> 函式來處理，函式定義如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>)</code></pre></div>
<p>假設我們還是需要產生上面的伺服器列表資訊，那麼如何來處理呢？請看下面的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;encoding/json&#34;</span>
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Server</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">ServerName</span> <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">ServerIP</span>   <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Serverslice</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Servers</span> []<span style="color:#a6e22e">Server</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#a6e22e">Serverslice</span>
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Servers</span> = append(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Servers</span>, <span style="color:#a6e22e">Server</span>{<span style="color:#a6e22e">ServerName</span>: <span style="color:#e6db74">&#34;Shanghai_VPN&#34;</span>, <span style="color:#a6e22e">ServerIP</span>: <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>})
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Servers</span> = append(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Servers</span>, <span style="color:#a6e22e">Server</span>{<span style="color:#a6e22e">ServerName</span>: <span style="color:#e6db74">&#34;Beijing_VPN&#34;</span>, <span style="color:#a6e22e">ServerIP</span>: <span style="color:#e6db74">&#34;127.0.0.2&#34;</span>})
	<span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">s</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;json err:&#34;</span>, <span style="color:#a6e22e">err</span>)
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">b</span>))
}</code></pre></div>
<p>輸出如下內容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#f92672">&#34;Servers&#34;</span>:[{<span style="color:#f92672">&#34;ServerName&#34;</span>:<span style="color:#e6db74">&#34;Shanghai_VPN&#34;</span>,<span style="color:#f92672">&#34;ServerIP&#34;</span>:<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>},{<span style="color:#f92672">&#34;ServerName&#34;</span>:<span style="color:#e6db74">&#34;Beijing_VPN&#34;</span>,<span style="color:#f92672">&#34;ServerIP&#34;</span>:<span style="color:#e6db74">&#34;127.0.0.2&#34;</span>}]}</code></pre></div>
<p>我們看到上面的輸出欄位名的首字母都是大寫的，如果你想用小寫的首字母怎麼辦呢？把結構體的欄位名改成首字母小寫的？JSON 輸出的時候必須注意，只有匯出的欄位才會被輸出，如果修改欄位名，那麼就會發現什麼都不會輸出，所以必須透過 struct tag 定義來實現：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Server</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">ServerName</span> <span style="color:#66d9ef">string</span> <span style="color:#e6db74">`json:&#34;serverName&#34;`</span>
	<span style="color:#a6e22e">ServerIP</span>   <span style="color:#66d9ef">string</span> <span style="color:#e6db74">`json:&#34;serverIP&#34;`</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Serverslice</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Servers</span> []<span style="color:#a6e22e">Server</span> <span style="color:#e6db74">`json:&#34;servers&#34;`</span>
}</code></pre></div>
<p>透過修改上面的結構體定義，輸出的 JSON 串就和我們最開始定義的 JSON 串保持一致了。</p>

<p>針對 JSON 的輸出，我們在定義 struct tag 的時候需要注意的幾點是:</p>

<ul>
<li>欄位的 tag 是<code>&quot;-&quot;</code>，那麼這個欄位不會輸出到 JSON</li>
<li>tag 中帶有自訂名稱，那麼這個自訂名稱會出現在 JSON 的欄位名中，例如上面例子中 serverName</li>
<li>tag 中如果帶有<code>&quot;omitempty&quot;</code>選項，那麼如果該欄位值為空，就不會輸出到 JSON 串中</li>
<li>如果欄位型別是 bool, string, int, int64 等，而 tag 中帶有<code>&quot;,string&quot;</code>選項，那麼這個欄位在輸出到 JSON 的時候會把該欄位對應的值轉換成 JSON 字串</li>
</ul>

<p>舉例來說：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Server</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#75715e">// ID 不會匯出到 JSON 中
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ID</span> <span style="color:#66d9ef">int</span> <span style="color:#e6db74">`json:&#34;-&#34;`</span>

	<span style="color:#75715e">// ServerName2 的值會進行二次 JSON 編碼
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ServerName</span>  <span style="color:#66d9ef">string</span> <span style="color:#e6db74">`json:&#34;serverName&#34;`</span>
	<span style="color:#a6e22e">ServerName2</span> <span style="color:#66d9ef">string</span> <span style="color:#e6db74">`json:&#34;serverName2,string&#34;`</span>

	<span style="color:#75715e">// 如果 ServerIP 為空，則不輸出到 JSON 串中
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ServerIP</span>   <span style="color:#66d9ef">string</span> <span style="color:#e6db74">`json:&#34;serverIP,omitempty&#34;`</span>
}

<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Server</span> {
	<span style="color:#a6e22e">ID</span>:         <span style="color:#ae81ff">3</span>,
	<span style="color:#a6e22e">ServerName</span>:  <span style="color:#e6db74">`Go &#34;1.0&#34; `</span>,
	<span style="color:#a6e22e">ServerName2</span>: <span style="color:#e6db74">`Go &#34;1.0&#34; `</span>,
	<span style="color:#a6e22e">ServerIP</span>:   <span style="color:#e6db74">``</span>,
}
<span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">b</span>)</code></pre></div>
<p>會輸出以下內容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#f92672">&#34;serverName&#34;</span>:<span style="color:#e6db74">&#34;Go \&#34;1.0\&#34; &#34;</span>,<span style="color:#f92672">&#34;serverName2&#34;</span>:<span style="color:#e6db74">&#34;\&#34;Go \\\&#34;1.0\\\&#34; \&#34;&#34;</span>}</code></pre></div>
<p>Marshal 函式只有在轉換成功的時候才會回傳資料，在轉換的過程中我們需要注意幾點：</p>

<ul>
<li>JSON 物件只支援 string 作為 key，所以要編碼一個 map，那麼必須是 map[string]T 這種型別(T 是 Go 語言中任意的型別)</li>
<li>Channel, complex 和 function 是不能被編碼成 JSON 的</li>
<li>巢狀的資料是不能編碼的，不然會讓 JSON 編碼進入無窮遞迴</li>
<li>指標在編碼的時候會輸出指標指向的內容，而空指標會輸出 null</li>
</ul>

<p>本小節，我們介紹了如何使用 Go 語言的 json 標準套件來編解碼 JSON 資料，同時也簡要介紹了如何使用第三方套件<code>go-simplejson</code>來在一些情況下簡化操作，學會並熟練運用它們將對我們接下來的 Web 開發相當重要。</p>

<h2 id="links">links</h2>

<ul>
<li><a href="docs/preface">目錄</a></li>
<li>上一節: <a href="docs/07.1">XML 處理</a></li>
<li>下一節: <a href="docs/07.3">正則處理</a></li>
</ul>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="/commit/fda25aafea9413c8ec77f5df29d5f6bb5f7dc3a6" title='Last modified Sep 21, 2019 by Jiuxiao' target="_blank" rel="noopener">
      <img src="/buildWebWithGolangTw/svg/calendar.svg" alt="Changed" /> Sep 21, 2019
    </a>
  </div>
  
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-3 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#7-2-json-處理">7.2 JSON 處理</a>
<ul>
<li><a href="#解析-json">解析 JSON</a>
<ul>
<li><a href="#解析到結構體">解析到結構體</a></li>
<li><a href="#解析到-interface">解析到 interface</a></li>
</ul></li>
<li><a href="#產生-json">產生 JSON</a></li>
<li><a href="#links">links</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-148025936-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>

</html>
