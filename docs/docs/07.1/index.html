<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>07.1 | 使用 Golang 打造 Web 應用程式</title>


<link rel="stylesheet" href="/buildWebWithGolangTw/book.min.89885fa0429ec73067282f26fc0c6d38cfc617a443ec4e835d47b821c52c6e92.css" integrity="sha256-iYhfoEKexzBnKC8m/AxtOM/GF6RD7E6DXUe4IcUsbpI=">


<script defer src="/buildWebWithGolangTw/search.min.1a26f030063cd84b7dd0472b3e255bc21c62c31322ab49b56f536fba41b42496.js" integrity="sha256-GibwMAY82Et90EcrPiVbwhxiwxMiq0m1b1NvukG0JJY="></script>



<link rel="icon" href="/buildWebWithGolangTw/favicon.png" type="image/x-icon">

<base href="https://ezzdoc.com/buildWebWithGolangTw/">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://ezzdoc.com/buildWebWithGolangTw/"><span>使用 Golang 打造 Web 應用程式</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" readonly />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    
  
  
  

  <style>
  nav ul a[href$="\2f buildWebWithGolangTw\2f docs\2f 07.1\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/buildWebWithGolangTw/docs/preface/">目錄</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.0/">1.Go 環境配置</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/01.1/">1.1 安裝 Go</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.2/">1.2 GOPATH 與工作空間</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.3/">1.3 Go 命令</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.4/">1.4 Go 開發工具</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.5/">1.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/02.0/">2.Go 語言基礎</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/02.1/">2.1 你好，Go</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.2/">2.2 Go 基礎</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.3/">2.3 流程和函式</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.4/">2.4 struct</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.5/">2.5 物件導向</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.6/">2.6 interface</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.7/">2.7 併發</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.8/">2.8 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/03.0/">3.Web 基礎</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/03.1/">3.1 web 工作方式</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.2/">3.2 Go 建立一個簡單的 web 服務</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.3/">3.3 Go 如何使得 web 工作</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.4/">3.4 Go 的 http 套件詳解</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.5/">3.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/04.0/">4.表單</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/04.1/">4.1 處理表單的輸入</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.2/">4.2 驗證表單的輸入</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.3/">4.3 預防跨站指令碼</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.4/">4.4 防止多次提交表單</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.5/">4.5 處理檔案上傳</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.6/">4.6 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/05.0/">5.訪問資料庫</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/05.1/">5.1 database/sql 介面</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.2/">5.2 使用 MySQL 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.3/">5.3 使用 SQLite 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.4/">5.4 使用 PostgreSQL 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.5/">5.5 使用 Beego orm 函式庫進行 ORM 開發</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.6/">5.6 NOSQL 資料庫操作</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.7/">5.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/06.0/">6.session 和資料儲存</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/06.1/">6.1 session 和 cookie</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.2/">6.2 Go 如何使用 session</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.3/">6.3 session 儲存</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.4/">6.4 預防 session 劫持</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.5/">6.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/07.0/">7.文字檔案處理</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/07.1/">7.1 XML 處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.2/">7.2 JSON 處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.3/">7.3 正則處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.4/">7.4 範本處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.5/">7.5 檔案操作</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.6/">7.6 字串處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.7/">7.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/08.0/">8.Web 服務</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/08.1/">8.1 Socket 程式設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.2/">8.2 WebSocket</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.3/">8.3 REST</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.4/">8.4 RPC</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.5/">8.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/09.0/">9.安全與加密</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/09.1/">9.1 預防 CSRF 攻擊</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.2/">9.2 確保輸入過濾</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.3/">9.3 避免 XSS 攻擊</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.4/">9.4 避免 SQL 注入</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.5/">9.5 儲存密碼</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.6/">9.6 加密和解密資料</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.7/">9.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/10.0/">10.國際化和本地化</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/10.1/">10.1 設定預設地區</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.2/">10.2 本地化資源</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.3/">10.3 國際化站點</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.4/">10.4 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/11.0/">11.錯誤處理，除錯和測試</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/11.1/">11.1 錯誤處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.2/">11.2 使用 GDB 除錯</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.3/">11.3 Go 怎麼寫測試案例</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.4/">11.4 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/12.0/">12.部署與維護</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/12.1/">12.1 應用日誌</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.2/">12.2 網站錯誤處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.3/">12.3 應用部署</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.4/">12.4 備份和還原</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.5/">12.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/13.0/">13.如何設計一個 Web 框架</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/13.1/">13.1 專案規劃</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.2/">13.2 自訂路由器設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.3/">13.3 controller 設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.4/">13.4 日誌和配置設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.5/">13.5 實現部落格的增刪改</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.6/">13.6 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/14.0/">14.擴充套件 Web 框架</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/14.1/">14.1 靜態檔案支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.2/">14.2 Session 支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.3/">14.3 表單支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.4/">14.4 使用者認證</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.5/">14.5 多語言支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.6/">14.6 pprof 支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.7/">14.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/ref/">附錄 A 參考資料</a></li>
</ul>







</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/buildWebWithGolangTw/svg/menu.svg" alt="Menu" />
  </label>
  <strong>07.1</strong>
</header>

      
<article class="markdown">

<h1 id="7-1-xml-處理">7.1 XML 處理</h1>

<p>XML 作為一種資料交換和資訊傳遞的格式已經十分普及。而隨著 Web 服務日益廣泛的應用，現在 XML 在日常的開發工作中也扮演了愈發重要的角色。這一小節， 我們將就 Go 語言標準套件中的 XML 相關處理的套件進行介紹。</p>

<p>這個小節不會涉及 XML 規範相關的內容（如需了解相關知識請參考其他文獻），而是介紹如何用 Go 語言來編解碼 XML 檔案相關的知識。</p>

<p>假如你是一名運維人員，你為你所管理的所有伺服器生成了如下內容的 xml 的配置檔案：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;</span>
<span style="color:#f92672">&lt;servers</span> <span style="color:#a6e22e">version=</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">&gt;</span>
	<span style="color:#f92672">&lt;server&gt;</span>
		<span style="color:#f92672">&lt;serverName&gt;</span>Shanghai_VPN<span style="color:#f92672">&lt;/serverName&gt;</span>
		<span style="color:#f92672">&lt;serverIP&gt;</span>127.0.0.1<span style="color:#f92672">&lt;/serverIP&gt;</span>
	<span style="color:#f92672">&lt;/server&gt;</span>
	<span style="color:#f92672">&lt;server&gt;</span>
		<span style="color:#f92672">&lt;serverName&gt;</span>Beijing_VPN<span style="color:#f92672">&lt;/serverName&gt;</span>
		<span style="color:#f92672">&lt;serverIP&gt;</span>127.0.0.2<span style="color:#f92672">&lt;/serverIP&gt;</span>
	<span style="color:#f92672">&lt;/server&gt;</span>
<span style="color:#f92672">&lt;/servers&gt;</span></code></pre></div>
<p>上面的 XML 文件描述了兩個伺服器的資訊，包含了伺服器名和伺服器的 IP 資訊，接下來的 Go 例子以此 XML 描述的資訊進行操作。</p>

<h2 id="解析-xml">解析 XML</h2>

<p>如何解析如上這個 XML 檔案呢？ 我們可以透過 xml 套件的 <code>Unmarshal</code> 函式來達到我們的目的</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">data</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">error</span></code></pre></div>
<p>data 接收的是 XML 資料流，v 是需要輸出的結構，定義為 interface，也就是可以把 XML 轉換為任意的格式。我們這裡主要介紹 struct 的轉換，因為 struct 和 XML 都有類似樹結構的特徵。</p>

<p>範例程式碼如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;encoding/xml&#34;</span>
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;io/ioutil&#34;</span>
	<span style="color:#e6db74">&#34;os&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Recurlyservers</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">XMLName</span>     <span style="color:#a6e22e">xml</span>.<span style="color:#a6e22e">Name</span> <span style="color:#e6db74">`xml:&#34;servers&#34;`</span>
	<span style="color:#a6e22e">Version</span>     <span style="color:#66d9ef">string</span>   <span style="color:#e6db74">`xml:&#34;version,attr&#34;`</span>
	<span style="color:#a6e22e">Svs</span>         []<span style="color:#a6e22e">server</span> <span style="color:#e6db74">`xml:&#34;server&#34;`</span>
	<span style="color:#a6e22e">Description</span> <span style="color:#66d9ef">string</span>   <span style="color:#e6db74">`xml:&#34;,innerxml&#34;`</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">server</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">XMLName</span>    <span style="color:#a6e22e">xml</span>.<span style="color:#a6e22e">Name</span> <span style="color:#e6db74">`xml:&#34;server&#34;`</span>
	<span style="color:#a6e22e">ServerName</span> <span style="color:#66d9ef">string</span>   <span style="color:#e6db74">`xml:&#34;serverName&#34;`</span>
	<span style="color:#a6e22e">ServerIP</span>   <span style="color:#66d9ef">string</span>   <span style="color:#e6db74">`xml:&#34;serverIP&#34;`</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">file</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Open</span>(<span style="color:#e6db74">&#34;servers.xml&#34;</span>) <span style="color:#75715e">// For read access.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;error: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Close</span>()
	<span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ioutil</span>.<span style="color:#a6e22e">ReadAll</span>(<span style="color:#a6e22e">file</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;error: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Recurlyservers</span>{}
	<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">xml</span>.<span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">data</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;error: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>)
}</code></pre></div>
<p>XML 本質上是一種樹狀結構，而我們可以定義與之匹配的 go 語言的 struct 型別，然後透過 xml.Unmarshal 來將 xml 中的資料解析成對應的 struct 物件。如上例子輸出如下資料</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">{{ servers} 1 [{{ server} Shanghai_VPN 127.0.0.1} {{ server} Beijing_VPN 127.0.0.2}]
<span style="color:#f92672">&lt;server&gt;</span>
	<span style="color:#f92672">&lt;serverName&gt;</span>Shanghai_VPN<span style="color:#f92672">&lt;/serverName&gt;</span>
	<span style="color:#f92672">&lt;serverIP&gt;</span>127.0.0.1<span style="color:#f92672">&lt;/serverIP&gt;</span>
<span style="color:#f92672">&lt;/server&gt;</span>
<span style="color:#f92672">&lt;server&gt;</span>
	<span style="color:#f92672">&lt;serverName&gt;</span>Beijing_VPN<span style="color:#f92672">&lt;/serverName&gt;</span>
	<span style="color:#f92672">&lt;serverIP&gt;</span>127.0.0.2<span style="color:#f92672">&lt;/serverIP&gt;</span>
<span style="color:#f92672">&lt;/server&gt;</span>
}</code></pre></div>
<p>上面的例子中，將 xml 檔案解析成對應的 struct 物件是透過<code>xml.Unmarshal</code>來完成的，這個過程是如何實現的？可以看到我們的 struct 定義後面多了一些類似於<code>xml:&quot;serverName&quot;</code>這樣的內容，這個是 struct 的一個特性，它們被稱為 struct tag，它們是用來輔助反射的。我們來看一下 <code>Unmarshal</code> 的定義：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">data</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">error</span></code></pre></div>
<p>我們看到函式定義了兩個參數，第一個是 XML 資料流，第二個是儲存的對應型別，目前支援 struct、slice 和 string，XML 套件內部採用了反射來進行資料的對映，所以 v 裡面的欄位必須是匯出的。<code>Unmarshal</code>解析的時候 XML 元素和欄位怎麼對應起來的呢？這是有一個優先順序讀取流程的，首先會讀取 struct tag，如果沒有，那麼就會對應欄位名。必須注意一點的是解析的時候 tag、欄位名、XML 元素都是區分大小寫的的，所以必須一一對應欄位。</p>

<p>Go 語言的反射機制，可以利用這些 tag 資訊來將來自 XML 檔案中的資料反射成對應的 struct 物件，關於反射如何利用 struct tag 的更多內容請參閱 reflect 中的相關內容。</p>

<p>解析 XML 到 struct 的時候遵循如下的規則：</p>

<ul>
<li><p>如果 struct 的一個欄位是 string 或者 []byte 型別且它的 tag 含有<code>&quot;,innerxml&quot;</code>，Unmarshal 將會將此欄位所對應的元素內所有內嵌的原始 xml 累加到此欄位上，如上面例子 Description 定義。最後的輸出是</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">	<span style="color:#f92672">&lt;server&gt;</span>
		<span style="color:#f92672">&lt;serverName&gt;</span>Shanghai_VPN<span style="color:#f92672">&lt;/serverName&gt;</span>
		<span style="color:#f92672">&lt;serverIP&gt;</span>127.0.0.1<span style="color:#f92672">&lt;/serverIP&gt;</span>
	<span style="color:#f92672">&lt;/server&gt;</span>
	<span style="color:#f92672">&lt;server&gt;</span>
		<span style="color:#f92672">&lt;serverName&gt;</span>Beijing_VPN<span style="color:#f92672">&lt;/serverName&gt;</span>
		<span style="color:#f92672">&lt;serverIP&gt;</span>127.0.0.2<span style="color:#f92672">&lt;/serverIP&gt;</span>
	<span style="color:#f92672">&lt;/server&gt;</span></code></pre></div></li>

<li><p>如果 struct 中有一個叫做 XMLName，且型別為 xml.Name 欄位，那麼在解析的時候就會儲存這個 element 的名字到該欄位，如上面例子中的 servers。</p></li>

<li><p>如果某個 struct 欄位的 tag 定義中含有 XML 結構中 element 的名稱，那麼解析的時候就會把相應的 element 值賦值給該欄位，如上 servername 和 serverip 定義。</p></li>

<li><p>如果某個 struct 欄位的 tag 定義了中含有<code>&quot;,attr&quot;</code>，那麼解析的時候就會將該結構所對應的 element 的與欄位同名的屬性的值賦值給該欄位，如上 version 定義。</p></li>

<li><p>如果某個 struct 欄位的 tag 定義 型如<code>&quot;a&gt;b&gt;c&quot;</code>，則解析的時候，會將 xml 結構 a 下面的 b 下面的 c 元素的值賦值給該欄位。</p></li>

<li><p>如果某個 struct 欄位的 tag 定義了<code>&quot;-&quot;</code>，那麼不會為該欄位解析匹配任何 xml 資料。</p></li>

<li><p>如果 struct 欄位後面的 tag 定義了<code>&quot;,any&quot;</code>，如果他的子元素在不滿足其他的規則的時候就會匹配到這個欄位。</p></li>

<li><p>如果某個 XML 元素包含一條或者多條註釋，那麼這些註釋將被累加到第一個 tag 含有&rdquo;,comments&rdquo;的欄位上，這個欄位的型別可能是 []byte 或 string，如果沒有這樣的欄位存在，那麼註釋將會被拋棄。</p></li>
</ul>

<p>上面詳細講述了如何定義 struct 的 tag。 只要設定對了 tag，那麼 XML 解析就如上面範例般簡單，tag 和 XML 的 element 是一一對應的關係，如上所示，我們還可以透過 slice 來表示多個同級元素。</p>

<blockquote>
<p>注意： 為了正確解析，go 語言的 xml 套件要求 struct 定義中的所有欄位必須是可匯出的（即首字母大寫）</p>
</blockquote>

<h2 id="輸出-xml">輸出 XML</h2>

<p>假若我們不是要解析如上所示的 XML 檔案，而是產生它，那麼在 go 語言中又該如何實現呢？ xml 套件中提供了 <code>Marshal</code> 和<code>MarshalIndent</code>兩個函式，來滿足我們的需求。這兩個函式主要的區別是第二個函式會增加字首和縮排，函式的定義如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">MarshalIndent</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">prefix</span>, <span style="color:#a6e22e">indent</span> <span style="color:#66d9ef">string</span>) ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>)</code></pre></div>
<p>兩個函式第一個參數是用來產生 XML 的結構定義型別資料，都是回傳產生的 XML 資料流。</p>

<p>下面我們來看一下如何輸出如上的 XML：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;encoding/xml&#34;</span>
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;os&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Servers</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">XMLName</span> <span style="color:#a6e22e">xml</span>.<span style="color:#a6e22e">Name</span> <span style="color:#e6db74">`xml:&#34;servers&#34;`</span>
	<span style="color:#a6e22e">Version</span> <span style="color:#66d9ef">string</span>   <span style="color:#e6db74">`xml:&#34;version,attr&#34;`</span>
	<span style="color:#a6e22e">Svs</span>     []<span style="color:#a6e22e">server</span> <span style="color:#e6db74">`xml:&#34;server&#34;`</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">server</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">ServerName</span> <span style="color:#66d9ef">string</span> <span style="color:#e6db74">`xml:&#34;serverName&#34;`</span>
	<span style="color:#a6e22e">ServerIP</span>   <span style="color:#66d9ef">string</span> <span style="color:#e6db74">`xml:&#34;serverIP&#34;`</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Servers</span>{<span style="color:#a6e22e">Version</span>: <span style="color:#e6db74">&#34;1&#34;</span>}
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Svs</span> = append(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Svs</span>, <span style="color:#a6e22e">server</span>{<span style="color:#e6db74">&#34;Shanghai_VPN&#34;</span>, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>})
	<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Svs</span> = append(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Svs</span>, <span style="color:#a6e22e">server</span>{<span style="color:#e6db74">&#34;Beijing_VPN&#34;</span>, <span style="color:#e6db74">&#34;127.0.0.2&#34;</span>})
	<span style="color:#a6e22e">output</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">xml</span>.<span style="color:#a6e22e">MarshalIndent</span>(<span style="color:#a6e22e">v</span>, <span style="color:#e6db74">&#34;  &#34;</span>, <span style="color:#e6db74">&#34;    &#34;</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;error: %v\n&#34;</span>, <span style="color:#a6e22e">err</span>)
	}
	<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>.<span style="color:#a6e22e">Write</span>([]byte(<span style="color:#a6e22e">xml</span>.<span style="color:#a6e22e">Header</span>))

	<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">output</span>)
}</code></pre></div>
<p>上面的程式碼輸出如下資訊：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span style="color:#f92672">&lt;servers</span> <span style="color:#a6e22e">version=</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;server&gt;</span>
	<span style="color:#f92672">&lt;serverName&gt;</span>Shanghai_VPN<span style="color:#f92672">&lt;/serverName&gt;</span>
	<span style="color:#f92672">&lt;serverIP&gt;</span>127.0.0.1<span style="color:#f92672">&lt;/serverIP&gt;</span>
<span style="color:#f92672">&lt;/server&gt;</span>
<span style="color:#f92672">&lt;server&gt;</span>
	<span style="color:#f92672">&lt;serverName&gt;</span>Beijing_VPN<span style="color:#f92672">&lt;/serverName&gt;</span>
	<span style="color:#f92672">&lt;serverIP&gt;</span>127.0.0.2<span style="color:#f92672">&lt;/serverIP&gt;</span>
<span style="color:#f92672">&lt;/server&gt;</span>
<span style="color:#f92672">&lt;/servers&gt;</span></code></pre></div>
<p>和我們之前定義的檔案的格式一模一樣，之所以會有<code>os.Stdout.Write([]byte(xml.Header))</code> 這句程式碼的出現，是因為<code>xml.MarshalIndent</code>或者<code>xml.Marshal</code>輸出的資訊都是不帶 XML 頭的，為了產生正確的 xml 檔案，我們使用了 xml 套件預定義的 Header 變數。</p>

<p>我們看到 <code>Marshal</code> 函式接收的參數 v 是 interface{}型別的，即它可以接受任意型別的參數，那麼 xml 套件，根據什麼規則來產生相應的 XML 檔案呢？</p>

<ul>
<li>如果 v 是 array 或者 slice，那麼輸出每一個元素，類似<type>value</type></li>
<li>如果 v 是指標，那麼會 Marshal 指標指向的內容，如果指標為空，什麼都不輸出</li>
<li>如果 v 是 interface，那麼就處理 interface 所包含的資料</li>
<li>如果 v 是其他資料型別，就會輸出這個資料型別所擁有的欄位資訊</li>
</ul>

<p>產生的 XML 檔案中的 element 的名字又是根據什麼決定的呢？元素名按照如下優先順序從 struct 中取得：</p>

<ul>
<li>如果 v 是 struct，XMLName 的 tag 中定義的名稱</li>
<li>型別為 xml.Name 的名叫 XMLName 的欄位的值</li>
<li>透過 struct 中欄位的 tag 來取得</li>
<li>透過 struct 的欄位名用來取得</li>
<li>marshall 的型別名稱</li>
</ul>

<p>我們應如何設定 struct 中欄位的 tag 資訊以控制最終 xml 檔案的產生呢？</p>

<ul>
<li>XMLName 不會被輸出</li>
<li>tag 中含有<code>&quot;-&quot;</code>的欄位不會輸出</li>
<li>tag 中含有<code>&quot;name,attr&quot;</code>，會以 name 作為屬性名，欄位值作為值輸出為這個 XML 元素的屬性，如上 version 欄位所描述</li>
<li>tag 中含有<code>&quot;,attr&quot;</code>，會以這個 struct 的欄位名作為屬性名輸出為 XML 元素的屬性，類似上一條，只是這個 name 預設是欄位名了。</li>
<li>tag 中含有<code>&quot;,chardata&quot;</code>，輸出為 xml 的 character data 而非 element。</li>
<li>tag 中含有<code>&quot;,innerxml&quot;</code>，將會被原樣輸出，而不會進行常規的編碼過程</li>
<li>tag 中含有<code>&quot;,comment&quot;</code>，將被當作 xml 註釋來輸出，而不會進行常規的編碼過程，欄位值中不能含有&rdquo;&ndash;&ldquo;字串</li>
<li>tag 中含有<code>&quot;omitempty&quot;</code>，如果該欄位的值為空值那麼該欄位就不會被輸出到 XML，空值包括：false、0、nil 指標或 nil 介面，任何長度為 0 的 array, slice, map 或者 string</li>

<li><p>tag 中含有<code>&quot;a&gt;b&gt;c&quot;</code>，那麼就會迴圈輸出三個元素 a 包含 b，b 包含 c，例如如下程式碼就會輸出</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">	FirstName string   `xml:&#34;name&gt;first&#34;`
	LastName  string   `xml:&#34;name&gt;last&#34;`

	<span style="color:#f92672">&lt;name&gt;</span>
	<span style="color:#f92672">&lt;first&gt;</span>Asta<span style="color:#f92672">&lt;/first&gt;</span>
	<span style="color:#f92672">&lt;last&gt;</span>Xie<span style="color:#f92672">&lt;/last&gt;</span>
	<span style="color:#f92672">&lt;/name&gt;</span></code></pre></div></li>
</ul>

<p>上面我們介紹了如何使用 Go 語言的 xml 套件來編/解碼 XML 檔案，重要的一點是對 XML 的所有操作都是透過 struct tag 來實現的，所以學會對 struct tag 的運用變得非常重要，在文章中我們簡要的列舉了如何定義 tag。更多內容或 tag 定義請參看相應的官方資料。</p>

<h2 id="links">links</h2>

<ul>
<li><a href="docs/preface">目錄</a></li>
<li>上一節: <a href="docs/07.0">文字處理</a></li>
<li>下一節: <a href="docs/07.2">Json 處理</a></li>
</ul>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="/commit/fda25aafea9413c8ec77f5df29d5f6bb5f7dc3a6" title='Last modified Sep 21, 2019 by Jiuxiao' target="_blank" rel="noopener">
      <img src="/buildWebWithGolangTw/svg/calendar.svg" alt="Changed" /> Sep 21, 2019
    </a>
  </div>
  
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-3 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#7-1-xml-處理">7.1 XML 處理</a>
<ul>
<li><a href="#解析-xml">解析 XML</a></li>
<li><a href="#輸出-xml">輸出 XML</a></li>
<li><a href="#links">links</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-148025936-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>

</html>
