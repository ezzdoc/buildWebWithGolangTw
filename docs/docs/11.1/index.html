<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>11.1 | 使用 Golang 打造 Web 應用程式</title>


<link rel="stylesheet" href="/buildWebWithGolangTw/book.min.89885fa0429ec73067282f26fc0c6d38cfc617a443ec4e835d47b821c52c6e92.css" integrity="sha256-iYhfoEKexzBnKC8m/AxtOM/GF6RD7E6DXUe4IcUsbpI=">


<script defer src="/buildWebWithGolangTw/search.min.1a26f030063cd84b7dd0472b3e255bc21c62c31322ab49b56f536fba41b42496.js" integrity="sha256-GibwMAY82Et90EcrPiVbwhxiwxMiq0m1b1NvukG0JJY="></script>



<link rel="icon" href="/buildWebWithGolangTw/favicon.png" type="image/x-icon">

<base href="https://ezzdoc.com/buildWebWithGolangTw/">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://ezzdoc.com/buildWebWithGolangTw/"><span>使用 Golang 打造 Web 應用程式</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" readonly />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    
  
  
  

  <style>
  nav ul a[href$="\2f buildWebWithGolangTw\2f docs\2f 11.1\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/buildWebWithGolangTw/docs/preface/">目錄</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.0/">1.Go 環境配置</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/01.1/">1.1 安裝 Go</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.2/">1.2 GOPATH 與工作空間</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.3/">1.3 Go 命令</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.4/">1.4 Go 開發工具</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.5/">1.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/02.0/">2.Go 語言基礎</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/02.1/">2.1 你好，Go</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.2/">2.2 Go 基礎</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.3/">2.3 流程和函式</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.4/">2.4 struct</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.5/">2.5 物件導向</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.6/">2.6 interface</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.7/">2.7 併發</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.8/">2.8 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/03.0/">3.Web 基礎</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/03.1/">3.1 web 工作方式</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.2/">3.2 Go 建立一個簡單的 web 服務</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.3/">3.3 Go 如何使得 web 工作</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.4/">3.4 Go 的 http 套件詳解</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.5/">3.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/04.0/">4.表單</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/04.1/">4.1 處理表單的輸入</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.2/">4.2 驗證表單的輸入</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.3/">4.3 預防跨站指令碼</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.4/">4.4 防止多次提交表單</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.5/">4.5 處理檔案上傳</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.6/">4.6 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/05.0/">5.訪問資料庫</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/05.1/">5.1 database/sql 介面</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.2/">5.2 使用 MySQL 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.3/">5.3 使用 SQLite 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.4/">5.4 使用 PostgreSQL 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.5/">5.5 使用 Beego orm 函式庫進行 ORM 開發</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.6/">5.6 NOSQL 資料庫操作</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.7/">5.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/06.0/">6.session 和資料儲存</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/06.1/">6.1 session 和 cookie</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.2/">6.2 Go 如何使用 session</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.3/">6.3 session 儲存</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.4/">6.4 預防 session 劫持</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.5/">6.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/07.0/">7.文字檔案處理</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/07.1/">7.1 XML 處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.2/">7.2 JSON 處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.3/">7.3 正則處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.4/">7.4 範本處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.5/">7.5 檔案操作</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.6/">7.6 字串處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.7/">7.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/08.0/">8.Web 服務</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/08.1/">8.1 Socket 程式設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.2/">8.2 WebSocket</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.3/">8.3 REST</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.4/">8.4 RPC</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.5/">8.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/09.0/">9.安全與加密</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/09.1/">9.1 預防 CSRF 攻擊</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.2/">9.2 確保輸入過濾</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.3/">9.3 避免 XSS 攻擊</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.4/">9.4 避免 SQL 注入</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.5/">9.5 儲存密碼</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.6/">9.6 加密和解密資料</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.7/">9.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/10.0/">10.國際化和本地化</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/10.1/">10.1 設定預設地區</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.2/">10.2 本地化資源</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.3/">10.3 國際化站點</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.4/">10.4 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/11.0/">11.錯誤處理，除錯和測試</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/11.1/">11.1 錯誤處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.2/">11.2 使用 GDB 除錯</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.3/">11.3 Go 怎麼寫測試案例</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.4/">11.4 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/12.0/">12.部署與維護</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/12.1/">12.1 應用日誌</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.2/">12.2 網站錯誤處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.3/">12.3 應用部署</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.4/">12.4 備份和還原</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.5/">12.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/13.0/">13.如何設計一個 Web 框架</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/13.1/">13.1 專案規劃</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.2/">13.2 自訂路由器設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.3/">13.3 controller 設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.4/">13.4 日誌和配置設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.5/">13.5 實現部落格的增刪改</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.6/">13.6 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/14.0/">14.擴充套件 Web 框架</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/14.1/">14.1 靜態檔案支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.2/">14.2 Session 支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.3/">14.3 表單支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.4/">14.4 使用者認證</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.5/">14.5 多語言支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.6/">14.6 pprof 支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.7/">14.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/ref/">附錄 A 參考資料</a></li>
</ul>







</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/buildWebWithGolangTw/svg/menu.svg" alt="Menu" />
  </label>
  <strong>11.1</strong>
</header>

      
<article class="markdown">

<h1 id="11-1-錯誤處理">11.1 錯誤處理</h1>

<p>Go 語言主要的設計準則是：簡潔、明白，簡潔是指語法和 C 類似，相當的簡單，明白是指任何語句都是很明顯的，不含有任何隱含的東西，在錯誤處理方案的設計中也貫徹了這一思想。我們知道在 C 語言裡面是透過回傳-1 或者 NULL 之類別的資訊來表示錯誤，但是對於使用者來說，不檢視相應的 API 說明文件，根本搞不清楚這個回傳值究竟代表什麼意思，比如 : 回傳 0 是成功，還是失敗，而 Go 定義了一個叫做 error 的型別，來明確的表達錯誤。在使用時，透過把回傳的 error 變數與 nil 的比較，來判定操作是否成功。例如<code>os.Open</code>函式在開啟檔案失敗時將回傳一個不為 nil 的 error 變數</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Open</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) (<span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">File</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)</code></pre></div>
<p>下面這個例子透過呼叫<code>os.Open</code>開啟一個檔案，如果出現錯誤，那麼就會呼叫<code>log.Fatal</code>來輸出錯誤資訊：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Open</span>(<span style="color:#e6db74">&#34;filename.ext&#34;</span>)
<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
	<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
}</code></pre></div>
<p>類似於<code>os.Open</code>函式，標準套件中所有可能出錯的 API 都會回傳一個 error 變數，以方便錯誤處理，這個小節將詳細地介紹 error 型別的設計，和討論開發 Web 應用中如何更好地處理 error。</p>

<h2 id="error-型別">Error 型別</h2>

<p>error 型別是一個介面型別，這是它的定義：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">error</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span>
}</code></pre></div>
<p>error 是一個內建的介面型別，我們可以在/builtin/套件下面找到相應的定義。而我們在很多內部套件裡面用到的 error 是 errors 套件下面的實現的私有結構 errorString</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#75715e">// errorString is a trivial implementation of error.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">errorString</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">errorString</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">s</span>
}</code></pre></div>
<p>你可以透過<code>errors.New</code>把一個字串轉化為 errorString，以得到一個滿足介面 error 的物件，其內部實現如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#75715e">// New returns an error that formats as the given text.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">text</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">errorString</span>{<span style="color:#a6e22e">text</span>}
}</code></pre></div>
<p>下面這個例子示範了如何使用<code>errors.New</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span>) (<span style="color:#66d9ef">float64</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">f</span> &lt; <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;math: square root of negative number&#34;</span>)
	}
	<span style="color:#75715e">// implementation
</span><span style="color:#75715e"></span>}</code></pre></div>
<p>在下面的例子中，我們在呼叫 Sqrt 的時候傳遞的一個負數，然後就得到了 non-nil 的 error 物件，將此物件與 nil 比較，結果為 true，所以 fmt.Println(fmt 套件在處理 error 時會呼叫 Error 方法)被呼叫，以輸出錯誤，請看下面呼叫的範例程式碼：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Sqrt</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
    }</code></pre></div>
<h2 id="自訂-error">自訂 Error</h2>

<p>透過上面的介紹我們知道 error 是一個 interface，所以在實現自己的套件的時候，透過定義實現此介面的結構，我們就可以實現自己的錯誤定義，請看來自 Json 套件的範例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SyntaxError</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">msg</span>    <span style="color:#66d9ef">string</span> <span style="color:#75715e">// 錯誤描述
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Offset</span> <span style="color:#66d9ef">int64</span>  <span style="color:#75715e">// 錯誤發生的位置
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SyntaxError</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">msg</span> }</code></pre></div>
<p>Offset 欄位在呼叫 Error 的時候不會被列印，但是我們可以透過型別斷言取得錯誤型別，然後可以列印相應的錯誤資訊，請看下面的例子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dec</span>.<span style="color:#a6e22e">Decode</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">val</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">serr</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">err</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">SyntaxError</span>); <span style="color:#a6e22e">ok</span> {
		<span style="color:#a6e22e">line</span>, <span style="color:#a6e22e">col</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">findLine</span>(<span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">serr</span>.<span style="color:#a6e22e">Offset</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;%s:%d:%d: %v&#34;</span>, <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Name</span>(), <span style="color:#a6e22e">line</span>, <span style="color:#a6e22e">col</span>, <span style="color:#a6e22e">err</span>)
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
}</code></pre></div>
<p>需要注意的是，函式回傳自訂錯誤時，回傳值推薦設定為 error 型別，而非自訂錯誤型別，特別需要注意的是不應預宣告自訂錯誤型別的變數。例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Decode</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">SyntaxError</span> { <span style="color:#75715e">// 錯誤，將可能導致上層呼叫者 err!=nil 的判斷永遠為 true。
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SyntaxError</span>     <span style="color:#75715e">// 預宣告錯誤變數
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">出錯條件</span> {
            <span style="color:#a6e22e">err</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">SyntaxError</span>{}
        }
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>               <span style="color:#75715e">// 錯誤，err 永遠等於非 nil，導致上層呼叫者 err!=nil 的判斷始終為 true
</span><span style="color:#75715e"></span>
    }</code></pre></div>
<p>原因見 <a href="http://golang.org/doc/faq#nil_error">http://golang.org/doc/faq#nil_error</a></p>

<p>上面例子簡單的示範了如何自訂 Error 型別。但是如果我們還需要更復雜的錯誤處理呢？此時，我們來參考一下 net 套件採用的方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">net</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Error</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#66d9ef">error</span>
    <span style="color:#a6e22e">Timeout</span>() <span style="color:#66d9ef">bool</span>   <span style="color:#75715e">// Is the error a timeout?
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Temporary</span>() <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// Is the error temporary?
</span><span style="color:#75715e"></span>}</code></pre></div>
<p>在呼叫的地方，透過型別斷言 err 是不是 net.Error，來細化錯誤的處理，例如下面的例子，如果一個網路發生臨時性錯誤，那麼將會 sleep 1 秒之後重試：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nerr</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">err</span>.(<span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Error</span>); <span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nerr</span>.<span style="color:#a6e22e">Temporary</span>() {
	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">1e9</span>)
	<span style="color:#66d9ef">continue</span>
}
<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
	<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
}</code></pre></div>
<h2 id="錯誤處理">錯誤處理</h2>

<p>Go 在錯誤處理上採用了與 C 類似的檢查回傳值的方式，而不是其他多數主流語言採用的異常方式，這造成了程式碼編寫上的一個很大的缺點 : 錯誤處理程式碼的冗餘，對於這種情況是我們透過複用檢測函式來減少類似的程式碼。</p>

<p>請看下面這個例子程式碼：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">init</span>() {
	<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">HandleFunc</span>(<span style="color:#e6db74">&#34;/view&#34;</span>, <span style="color:#a6e22e">viewRecord</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">viewRecord</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">appengine</span>.<span style="color:#a6e22e">NewContext</span>(<span style="color:#a6e22e">r</span>)
	<span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">datastore</span>.<span style="color:#a6e22e">NewKey</span>(<span style="color:#a6e22e">c</span>, <span style="color:#e6db74">&#34;Record&#34;</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">FormValue</span>(<span style="color:#e6db74">&#34;id&#34;</span>), <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">nil</span>)
	<span style="color:#a6e22e">record</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">Record</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">datastore</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">record</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>(), <span style="color:#ae81ff">500</span>)
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">viewTemplate</span>.<span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">record</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>(), <span style="color:#ae81ff">500</span>)
	}
}</code></pre></div>
<p>上面的例子中取得資料和範本展示呼叫時都有檢測錯誤，當有錯誤發生時，呼叫了統一的處理函式<code>http.Error</code>，回傳給客戶端 500 錯誤碼，並顯示相應的錯誤資料。但是當越來越多的 HandleFunc 加入之後，這樣的錯誤處理邏輯程式碼就會越來越多，其實我們可以透過自訂路由器來縮減程式碼(實現的思路可以參考第三章的 HTTP 詳解)。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">appHandler</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) <span style="color:#66d9ef">error</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">fn</span> <span style="color:#a6e22e">appHandler</span>) <span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">r</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>(), <span style="color:#ae81ff">500</span>)
	}
}</code></pre></div>
<p>上面我們定義了自訂的路由器，然後我們可以透過如下方式來註冊函式：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">init</span>() {
	<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Handle</span>(<span style="color:#e6db74">&#34;/view&#34;</span>, <span style="color:#a6e22e">appHandler</span>(<span style="color:#a6e22e">viewRecord</span>))
}</code></pre></div>
<p>當請求/view 的時候我們的邏輯處理可以變成如下程式碼，和第一種實現方式相比較已經簡單了很多。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">viewRecord</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">appengine</span>.<span style="color:#a6e22e">NewContext</span>(<span style="color:#a6e22e">r</span>)
	<span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">datastore</span>.<span style="color:#a6e22e">NewKey</span>(<span style="color:#a6e22e">c</span>, <span style="color:#e6db74">&#34;Record&#34;</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">FormValue</span>(<span style="color:#e6db74">&#34;id&#34;</span>), <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">nil</span>)
	<span style="color:#a6e22e">record</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">Record</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">datastore</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">record</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">viewTemplate</span>.<span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">record</span>)
}</code></pre></div>
<p>上面的例子錯誤處理的時候所有的錯誤回傳給使用者的都是 500 錯誤碼，然後顯示出來相應的錯誤程式碼，其實我們可以把這個錯誤資訊定義的更加友好，除錯的時候也方便定位問題，我們可以自訂回傳的錯誤型別：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">appError</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Error</span>   <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">Message</span> <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">Code</span>    <span style="color:#66d9ef">int</span>
}</code></pre></div>
<p>這樣我們的自訂路由器可以改成如下方式：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">appHandler</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">appError</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">fn</span> <span style="color:#a6e22e">appHandler</span>) <span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">r</span>); <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> { <span style="color:#75715e">// e is *appError, not os.Error.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">appengine</span>.<span style="color:#a6e22e">NewContext</span>(<span style="color:#a6e22e">r</span>)
		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;%v&#34;</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Error</span>)
		<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Message</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Code</span>)
	}
}</code></pre></div>
<p>這樣修改完自訂錯誤之後，我們的邏輯處理可以改成如下方式：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">viewRecord</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">appError</span> {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">appengine</span>.<span style="color:#a6e22e">NewContext</span>(<span style="color:#a6e22e">r</span>)
	<span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">datastore</span>.<span style="color:#a6e22e">NewKey</span>(<span style="color:#a6e22e">c</span>, <span style="color:#e6db74">&#34;Record&#34;</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">FormValue</span>(<span style="color:#e6db74">&#34;id&#34;</span>), <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">nil</span>)
	<span style="color:#a6e22e">record</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">Record</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">datastore</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">record</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">appError</span>{<span style="color:#a6e22e">err</span>, <span style="color:#e6db74">&#34;Record not found&#34;</span>, <span style="color:#ae81ff">404</span>}
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">viewTemplate</span>.<span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">record</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">appError</span>{<span style="color:#a6e22e">err</span>, <span style="color:#e6db74">&#34;Can&#39;t display record&#34;</span>, <span style="color:#ae81ff">500</span>}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}</code></pre></div>
<p>如上所示，在我們訪問 view 的時候可以根據不同的情況取得不同的錯誤碼和錯誤資訊，雖然這個和第一個版本的程式碼量差不多，但是這個顯示的錯誤更加明顯，提示的錯誤資訊更加友好，擴充套件性也比第一個更好。</p>

<h2 id="總結">總結</h2>

<p>在程式設計中，容錯是相當重要的一部分工作，在 Go 中它是透過錯誤處理來實現的，error 雖然只是一個介面，但是其變化卻可以有很多，我們可以根據自己的需求來實現不同的處理，最後介紹的錯誤處理方案，希望能給大家在如何設計更好 Web 錯誤處理方案上帶來一點思路。</p>

<h2 id="links">links</h2>

<ul>
<li><a href="docs/preface">目錄</a></li>
<li>上一節: <a href="docs/11.0">錯誤處理，除錯和測試</a></li>
<li>下一節: <a href="docs/11.2">使用 GDB 除錯</a></li>
</ul>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="/commit/fda25aafea9413c8ec77f5df29d5f6bb5f7dc3a6" title='Last modified Sep 21, 2019 by Jiuxiao' target="_blank" rel="noopener">
      <img src="/buildWebWithGolangTw/svg/calendar.svg" alt="Changed" /> Sep 21, 2019
    </a>
  </div>
  
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-3 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#11-1-錯誤處理">11.1 錯誤處理</a>
<ul>
<li><a href="#error-型別">Error 型別</a></li>
<li><a href="#自訂-error">自訂 Error</a></li>
<li><a href="#錯誤處理">錯誤處理</a></li>
<li><a href="#總結">總結</a></li>
<li><a href="#links">links</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-148025936-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>

</html>
