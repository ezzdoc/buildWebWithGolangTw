<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>02.7 | 使用 Golang 打造 Web 應用程式</title>


<link rel="stylesheet" href="/buildWebWithGolangTw/book.min.89885fa0429ec73067282f26fc0c6d38cfc617a443ec4e835d47b821c52c6e92.css" integrity="sha256-iYhfoEKexzBnKC8m/AxtOM/GF6RD7E6DXUe4IcUsbpI=">


<script defer src="/buildWebWithGolangTw/search.min.1a26f030063cd84b7dd0472b3e255bc21c62c31322ab49b56f536fba41b42496.js" integrity="sha256-GibwMAY82Et90EcrPiVbwhxiwxMiq0m1b1NvukG0JJY="></script>



<link rel="icon" href="/buildWebWithGolangTw/favicon.png" type="image/x-icon">

<base href="https://ezzdoc.com/buildWebWithGolangTw/">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://ezzdoc.com/buildWebWithGolangTw/"><span>使用 Golang 打造 Web 應用程式</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" readonly />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    
  
  
  

  <style>
  nav ul a[href$="\2f buildWebWithGolangTw\2f docs\2f 02.7\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/buildWebWithGolangTw/docs/preface/">目錄</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.0/">1.Go 環境配置</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/01.1/">1.1 安裝 Go</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.2/">1.2 GOPATH 與工作空間</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.3/">1.3 Go 命令</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.4/">1.4 Go 開發工具</a></li>
<li><a href="/buildWebWithGolangTw/docs/01.5/">1.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/02.0/">2.Go 語言基礎</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/02.1/">2.1 你好，Go</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.2/">2.2 Go 基礎</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.3/">2.3 流程和函式</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.4/">2.4 struct</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.5/">2.5 物件導向</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.6/">2.6 interface</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.7/">2.7 併發</a></li>
<li><a href="/buildWebWithGolangTw/docs/02.8/">2.8 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/03.0/">3.Web 基礎</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/03.1/">3.1 web 工作方式</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.2/">3.2 Go 建立一個簡單的 web 服務</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.3/">3.3 Go 如何使得 web 工作</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.4/">3.4 Go 的 http 套件詳解</a></li>
<li><a href="/buildWebWithGolangTw/docs/03.5/">3.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/04.0/">4.表單</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/04.1/">4.1 處理表單的輸入</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.2/">4.2 驗證表單的輸入</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.3/">4.3 預防跨站指令碼</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.4/">4.4 防止多次提交表單</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.5/">4.5 處理檔案上傳</a></li>
<li><a href="/buildWebWithGolangTw/docs/04.6/">4.6 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/05.0/">5.訪問資料庫</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/05.1/">5.1 database/sql 介面</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.2/">5.2 使用 MySQL 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.3/">5.3 使用 SQLite 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.4/">5.4 使用 PostgreSQL 資料庫</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.5/">5.5 使用 Beego orm 函式庫進行 ORM 開發</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.6/">5.6 NOSQL 資料庫操作</a></li>
<li><a href="/buildWebWithGolangTw/docs/05.7/">5.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/06.0/">6.session 和資料儲存</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/06.1/">6.1 session 和 cookie</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.2/">6.2 Go 如何使用 session</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.3/">6.3 session 儲存</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.4/">6.4 預防 session 劫持</a></li>
<li><a href="/buildWebWithGolangTw/docs/06.5/">6.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/07.0/">7.文字檔案處理</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/07.1/">7.1 XML 處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.2/">7.2 JSON 處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.3/">7.3 正則處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.4/">7.4 範本處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.5/">7.5 檔案操作</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.6/">7.6 字串處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/07.7/">7.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/08.0/">8.Web 服務</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/08.1/">8.1 Socket 程式設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.2/">8.2 WebSocket</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.3/">8.3 REST</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.4/">8.4 RPC</a></li>
<li><a href="/buildWebWithGolangTw/docs/08.5/">8.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/09.0/">9.安全與加密</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/09.1/">9.1 預防 CSRF 攻擊</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.2/">9.2 確保輸入過濾</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.3/">9.3 避免 XSS 攻擊</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.4/">9.4 避免 SQL 注入</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.5/">9.5 儲存密碼</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.6/">9.6 加密和解密資料</a></li>
<li><a href="/buildWebWithGolangTw/docs/09.7/">9.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/10.0/">10.國際化和本地化</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/10.1/">10.1 設定預設地區</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.2/">10.2 本地化資源</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.3/">10.3 國際化站點</a></li>
<li><a href="/buildWebWithGolangTw/docs/10.4/">10.4 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/11.0/">11.錯誤處理，除錯和測試</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/11.1/">11.1 錯誤處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.2/">11.2 使用 GDB 除錯</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.3/">11.3 Go 怎麼寫測試案例</a></li>
<li><a href="/buildWebWithGolangTw/docs/11.4/">11.4 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/12.0/">12.部署與維護</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/12.1/">12.1 應用日誌</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.2/">12.2 網站錯誤處理</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.3/">12.3 應用部署</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.4/">12.4 備份和還原</a></li>
<li><a href="/buildWebWithGolangTw/docs/12.5/">12.5 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/13.0/">13.如何設計一個 Web 框架</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/13.1/">13.1 專案規劃</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.2/">13.2 自訂路由器設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.3/">13.3 controller 設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.4/">13.4 日誌和配置設計</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.5/">13.5 實現部落格的增刪改</a></li>
<li><a href="/buildWebWithGolangTw/docs/13.6/">13.6 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/14.0/">14.擴充套件 Web 框架</a>

<ul>
<li><a href="/buildWebWithGolangTw/docs/14.1/">14.1 靜態檔案支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.2/">14.2 Session 支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.3/">14.3 表單支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.4/">14.4 使用者認證</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.5/">14.5 多語言支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.6/">14.6 pprof 支援</a></li>
<li><a href="/buildWebWithGolangTw/docs/14.7/">14.7 小結</a></li>
</ul></li>
<li><a href="/buildWebWithGolangTw/docs/ref/">附錄 A 參考資料</a></li>
</ul>







</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/buildWebWithGolangTw/svg/menu.svg" alt="Menu" />
  </label>
  <strong>02.7</strong>
</header>

      
<article class="markdown">

<h1 id="2-7-併發">2.7 併發</h1>

<p>有人把 Go 比作 21 世紀的 C 語言，第一是因為 Go 語言設計簡單，第二，21 世紀最重要的就是並行程式設計，而 Go 從語言層面就支援了並行。</p>

<h2 id="goroutine">goroutine</h2>

<p>goroutine 是 Go 並行設計的核心。goroutine 說到底其實就是<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B">協程</a> (Coroutine)，但是它比執行緒更小，十幾個 goroutine 可能體現在底層就是五六個執行緒，Go 語言內部幫你實現了這些 goroutine 之間的記憶體共享。執行 goroutine 只需極少的棧記憶體(大概是 4~5KB)，當然會根據相應的資料伸縮。也正因為如此，可同時執行成千上萬個併發任務。goroutine 比 thread 更易用、更高效、更輕便。</p>

<p>goroutine 是透過 Go 的 runtime 管理的一個執行緒管理器。goroutine 透過 <code>go</code> 關鍵字實現了，其實就是一個普通的函式。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">go</span> <span style="color:#a6e22e">hello</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span>)</code></pre></div>
<p>透過關鍵字 go 就啟動了一個 goroutine。我們來看一個例子</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;runtime&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Gosched</span>()
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">say</span>(<span style="color:#e6db74">&#34;world&#34;</span>) <span style="color:#75715e">//開一個新的 Goroutines 執行
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">say</span>(<span style="color:#e6db74">&#34;hello&#34;</span>) <span style="color:#75715e">//當前 Goroutines 執行
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 以上程式執行後將輸出：
</span><span style="color:#75715e">// hello
</span><span style="color:#75715e">// world
</span><span style="color:#75715e">// hello
</span><span style="color:#75715e">// world
</span><span style="color:#75715e">// hello
</span><span style="color:#75715e">// world
</span><span style="color:#75715e">// hello
</span><span style="color:#75715e">// world
</span><span style="color:#75715e"></span><span style="color:#f92672">//</span> <span style="color:#a6e22e">hello</span></code></pre></div>
<p>我們可以看到 go 關鍵字很方便的就實現了併發程式設計。
上面的多個 goroutine 執行在同一個程序裡面，共享記憶體資料，不過設計上我們要遵循：不要透過共享來通訊，而要透過通訊來共享。</p>

<blockquote>
<p>runtime.Gosched()表示讓 CPU 把時間片讓給別人，下次某個時候繼續恢復執行該 goroutine。</p>

<p>預設情況下，在 Go 1.5 將標識併發系統執行緒個數的 runtime.GOMAXPROCS 的初始值由 1 改為了執行環境的 CPU 核數。</p>
</blockquote>

<p>但在 Go 1.5 以前排程器僅使用單執行緒，也就是說只實現了併發。想要發揮多核處理器的並行，需要在我們的程式中明確的呼叫 runtime.GOMAXPROCS(n) 告訴排程器同時使用多個執行緒。GOMAXPROCS 設定了同時執行邏輯程式碼的系統執行緒的最大數量，並回傳之前的設定。如果 n &lt; 1，不會改變當前設定。</p>

<h2 id="channels">channels</h2>

<p>goroutine 執行在相同的地址空間，因此訪問共享記憶體必須做好同步。那麼 goroutine 之間如何進行資料的通訊呢，Go 提供了一個很好的通訊機制 channel。channel 可以與 Unix shell 中的雙向管道做類別比：可以透過它傳送或者接收值。這些值只能是特定的型別：channel 型別。定義一個 channel 時，也需要定義傳送到 channel 的值的型別。注意，必須使用 make 建立 channel：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">ci</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
<span style="color:#a6e22e">cs</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>)
<span style="color:#a6e22e">cf</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">interface</span>{})</code></pre></div>
<p>channel 透過運算子<code>&lt;-</code>來接收和傳送資料</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">v</span>    <span style="color:#75715e">// 傳送 v 到 channel ch.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>  <span style="color:#f92672">//</span> <span style="color:#a6e22e">從</span> <span style="color:#a6e22e">ch</span> <span style="color:#a6e22e">中接收資料</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">並賦值給</span> <span style="color:#a6e22e">v</span></code></pre></div>
<p>我們把這些應用到我們的例子中來：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">a</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">total</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">a</span> {
		<span style="color:#a6e22e">total</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">v</span>
	}
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">total</span>  <span style="color:#75715e">// send total to c
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>}

	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">a</span>[:len(<span style="color:#a6e22e">a</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>], <span style="color:#a6e22e">c</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">a</span>[len(<span style="color:#a6e22e">a</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>:], <span style="color:#a6e22e">c</span>)
	<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>, <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>  <span style="color:#75715e">// receive from c
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>)
}</code></pre></div>
<p>預設情況下，channel 接收和傳送資料都是阻塞的，除非另一端已經準備好，這樣就使得 Goroutines 同步變的更加的簡單，而不需要明確的 lock。所謂阻塞，也就是如果讀取（value := &lt;-ch）它將會被阻塞，直到有資料接收。其次，任何傳送（ch&lt;-5）將會被阻塞，直到資料被讀出。無緩衝 channel 是在多個 goroutine 之間同步很棒的工具。</p>

<h2 id="buffered-channels">Buffered Channels</h2>

<p>上面我們介紹了預設的非快取型別的 channel，不過 Go 也允許指定 channel 的緩衝大小，很簡單，就是 channel 可以儲存多少元素。ch:= make(chan bool, 4)，建立了可以儲存 4 個元素的 bool 型 channel。在這個 channel 中，前 4 個元素可以無阻塞的寫入。當寫入第 5 個元素時，程式碼將會阻塞，直到其他 goroutine 從 channel 中讀取一些元素，騰出空間。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">type</span>, <span style="color:#a6e22e">value</span>)</code></pre></div>
<p>當 value = 0 時，channel 是無緩衝阻塞讀寫的，當 value &gt; 0 時，channel 有緩衝、是非阻塞的，直到寫滿 value 個元素才阻塞寫入。</p>

<p>我們看一下下面這個例子，你可以在自己本機測試一下，修改相應的 value 值</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>)<span style="color:#75715e">//修改 2 為 1 就報錯，修改 2 為 3 可以正常執行
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">2</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>)
}
        <span style="color:#75715e">//修改為 1 報如下的錯誤:
</span><span style="color:#75715e"></span>        <span style="color:#f92672">//</span><span style="color:#a6e22e">fatal</span> <span style="color:#66d9ef">error</span>: <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">goroutines</span> <span style="color:#a6e22e">are</span> <span style="color:#a6e22e">asleep</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">deadlock</span>!</code></pre></div>
<h2 id="range-和-close">Range 和 Close</h2>

<p>上面這個例子中，我們需要讀取兩次 c，這樣不是很方便，Go 考慮到了這一點，所以也可以透過 range，像操作 slice 或者 map 一樣操作快取型別的 channel，請看下面的例子</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fibonacci</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">x</span>
		<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
	}
	close(<span style="color:#a6e22e">c</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">fibonacci</span>(cap(<span style="color:#a6e22e">c</span>), <span style="color:#a6e22e">c</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">c</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
	}
}</code></pre></div>
<p><code>for i := range c</code>能夠不斷的讀取 channel 裡面的資料，直到該 channel 被明確的關閉。上面程式碼我們看到可以明確的關閉 channel，生產者透過內建函式 <code>close</code> 關閉 channel。關閉 channel 之後就無法再發送任何資料了，在消費方可以透過語法<code>v, ok := &lt;-ch</code>測試 channel 是否被關閉。如果 ok 回傳 false，那麼說明 channel 已經沒有任何資料並且已經被關閉。</p>

<blockquote>
<p>記住應該在生產者的地方關閉 channel，而不是消費的地方去關閉它，這樣容易引起 panic</p>

<p>另外記住一點的就是 channel 不像檔案之類別的，不需要經常去關閉，只有當你確實沒有任何傳送資料了，或者你想明確的結束 range 迴圈之類別的</p>
</blockquote>

<h2 id="select">Select</h2>

<p>我們上面介紹的都是隻有一個 channel 的情況，那麼如果存在多個 channel 的時候，我們該如何操作呢，Go 裡面提供了一個關鍵字<code>select</code>，透過 <code>select</code> 可以監聽 channel 上的資料流動。</p>

<p><code>select</code> 預設是阻塞的，只有當監聽的 channel 中有傳送或接收可以進行時才會執行，當多個 channel 都準備好的時候，select 會隨機選擇其中一個執行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fibonacci</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">quit</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> {
		<span style="color:#66d9ef">select</span> {
		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">x</span>:
			<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">quit</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;quit&#34;</span>)
			<span style="color:#66d9ef">return</span>
		}
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">quit</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>)
		}
		<span style="color:#a6e22e">quit</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">0</span>
	}()
	<span style="color:#a6e22e">fibonacci</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">quit</span>)
}</code></pre></div>
<p>在 <code>select</code> 裡面還有 default 語法，<code>select</code>其實就是類似 switch 的功能，default 就是當監聽的 channel 都沒有準備好的時候，預設執行的（select 不再阻塞等待 channel）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">select</span> {
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>:
	<span style="color:#75715e">// use i
</span><span style="color:#75715e"></span><span style="color:#66d9ef">default</span>:
	<span style="color:#75715e">// 當 c 阻塞的時候執行這裡
</span><span style="color:#75715e"></span>}</code></pre></div>
<h2 id="超時">超時</h2>

<p>有時候會出現 goroutine 阻塞的情況，那麼我們如何避免整個程式進入阻塞的情況呢？我們可以利用 select 來設定超時，透過如下的方式實現：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Go" data-lang="Go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">o</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">for</span> {
			<span style="color:#66d9ef">select</span> {
				<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">c</span>:
					println(<span style="color:#a6e22e">v</span>)
				<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">After</span>(<span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>):
					println(<span style="color:#e6db74">&#34;timeout&#34;</span>)
					<span style="color:#a6e22e">o</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">true</span>
					<span style="color:#66d9ef">break</span>
			}
		}
	}()
	<span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">o</span>
}</code></pre></div>
<h2 id="runtime-goroutine">runtime goroutine</h2>

<p>runtime 套件中有幾個處理 goroutine 的函式：</p>

<ul>
<li><p>Goexit</p>

<p>退出當前執行的 goroutine，但是 defer 函式還會繼續呼叫</p></li>

<li><p>Gosched</p>

<p>讓出當前 goroutine 的執行許可權，排程器安排其他等待的任務執行，並在下次某個時候從該位置恢復執行。</p></li>

<li><p>NumCPU</p>

<p>回傳 CPU 核數量</p></li>

<li><p>NumGoroutine</p>

<p>回傳正在執行和排隊的任務總數</p></li>

<li><p>GOMAXPROCS</p>

<p>用來設定可以平行計算的 CPU 核數的最大值，並回傳之前的值。</p></li>
</ul>

<h2 id="links">links</h2>

<ul>
<li><a href="docs/preface">目錄</a></li>
<li>上一章: <a href="docs/02.6">interface</a></li>
<li>下一節: <a href="docs/02.8">總結</a></li>
</ul>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="/commit/fda25aafea9413c8ec77f5df29d5f6bb5f7dc3a6" title='Last modified Sep 21, 2019 by Jiuxiao' target="_blank" rel="noopener">
      <img src="/buildWebWithGolangTw/svg/calendar.svg" alt="Changed" /> Sep 21, 2019
    </a>
  </div>
  
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-3 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#2-7-併發">2.7 併發</a>
<ul>
<li><a href="#goroutine">goroutine</a></li>
<li><a href="#channels">channels</a></li>
<li><a href="#buffered-channels">Buffered Channels</a></li>
<li><a href="#range-和-close">Range 和 Close</a></li>
<li><a href="#select">Select</a></li>
<li><a href="#超時">超時</a></li>
<li><a href="#runtime-goroutine">runtime goroutine</a></li>
<li><a href="#links">links</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-148025936-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>

</html>
